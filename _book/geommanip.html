<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Spatial Data Science</title>
  <meta name="description" content="description_xx">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Spatial Data Science" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="description_xx" />
  <meta name="github-repo" content="edzer/sdsr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Spatial Data Science" />
  
  <meta name="twitter:description" content="description_xx" />
  

<meta name="author" content="Edzer Pebesma, Roger Bivand">


<meta name="date" content="2019-01-12">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="raster.html">
<link rel="next" href="featureattributes.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-1.2/htmlwidgets.js"></script>
<link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-1.3.1/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<script src="libs/Proj4Leaflet-1.0.1/proj4-compressed.js"></script>
<script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script>
<link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-binding-2.0.2/leaflet.js"></script>
<script src="libs/leaflet-providers-1.1.17/leaflet-providers.js"></script>
<script src="libs/leaflet-providers-plugin-2.0.2/leaflet-providers-plugin.js"></script>
<link href="libs/HomeButton-0.0.1/home-button.css" rel="stylesheet" />
<script src="libs/HomeButton-0.0.1/home-button.js"></script>
<script src="libs/HomeButton-0.0.1/easy-button-src.min.js"></script>
<link href="libs/PopupTable-0.0.1/popup.css" rel="stylesheet" />


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Spatial Data Science</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="part"><span><b>I Spatial Data</b></span></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Getting Started</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#a-first-map"><i class="fa fa-check"></i><b>1.1</b> A first map</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#reading"><i class="fa fa-check"></i><b>1.2</b> Reading and writing</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.3</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="cs.html"><a href="cs.html"><i class="fa fa-check"></i><b>2</b> Coordinate systems</a><ul>
<li class="chapter" data-level="2.1" data-path="cs.html"><a href="cs.html#cartesian-and-geodetic-coordinates"><i class="fa fa-check"></i><b>2.1</b> Cartesian and geodetic coordinates</a></li>
<li class="chapter" data-level="2.2" data-path="cs.html"><a href="cs.html#ellipsoidal-coordinates"><i class="fa fa-check"></i><b>2.2</b> Ellipsoidal coordinates</a></li>
<li class="chapter" data-level="2.3" data-path="cs.html"><a href="cs.html#distances"><i class="fa fa-check"></i><b>2.3</b> Distances</a></li>
<li class="chapter" data-level="2.4" data-path="cs.html"><a href="cs.html#bounded-spaces"><i class="fa fa-check"></i><b>2.4</b> Bounded spaces</a></li>
<li class="chapter" data-level="2.5" data-path="cs.html"><a href="cs.html#time"><i class="fa fa-check"></i><b>2.5</b> Time</a></li>
<li class="chapter" data-level="2.6" data-path="cs.html"><a href="cs.html#exercises-1"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="geometries.html"><a href="geometries.html"><i class="fa fa-check"></i><b>3</b> Geometries</a><ul>
<li class="chapter" data-level="3.1" data-path="geometries.html"><a href="geometries.html#simple-feature-geometry-types"><i class="fa fa-check"></i><b>3.1</b> Simple feature geometry types</a></li>
<li class="chapter" data-level="3.2" data-path="geometries.html"><a href="geometries.html#simple-features-in-sf"><i class="fa fa-check"></i><b>3.2</b> Simple features in <code>sf</code></a></li>
<li class="chapter" data-level="3.3" data-path="geometries.html"><a href="geometries.html#geomraster"><i class="fa fa-check"></i><b>3.3</b> Tesselations: coverages, rasters</a></li>
<li class="chapter" data-level="3.4" data-path="geometries.html"><a href="geometries.html#networks"><i class="fa fa-check"></i><b>3.4</b> Networks</a></li>
<li class="chapter" data-level="3.5" data-path="geometries.html"><a href="geometries.html#geometries-on-the-sphere"><i class="fa fa-check"></i><b>3.5</b> Geometries on the sphere</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="raster.html"><a href="raster.html"><i class="fa fa-check"></i><b>4</b> Raster and vector datacubes</a><ul>
<li class="chapter" data-level="4.1" data-path="raster.html"><a href="raster.html#package-stars"><i class="fa fa-check"></i><b>4.1</b> Package <code>stars</code></a></li>
<li class="chapter" data-level="4.2" data-path="raster.html"><a href="raster.html#raster-data"><i class="fa fa-check"></i><b>4.2</b> Raster data</a></li>
<li class="chapter" data-level="4.3" data-path="raster.html"><a href="raster.html#datacubes"><i class="fa fa-check"></i><b>4.3</b> Vector Datacubes</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="geommanip.html"><a href="geommanip.html"><i class="fa fa-check"></i><b>5</b> Manipulating Geometries</a><ul>
<li class="chapter" data-level="5.1" data-path="geommanip.html"><a href="geommanip.html#predicates"><i class="fa fa-check"></i><b>5.1</b> Predicates</a></li>
<li class="chapter" data-level="5.2" data-path="geommanip.html"><a href="geommanip.html#measures"><i class="fa fa-check"></i><b>5.2</b> Measures</a></li>
<li class="chapter" data-level="5.3" data-path="geommanip.html"><a href="geommanip.html#geometry-generating-functions"><i class="fa fa-check"></i><b>5.3</b> Geometry generating functions</a></li>
<li class="chapter" data-level="5.4" data-path="geommanip.html"><a href="geommanip.html#precision"><i class="fa fa-check"></i><b>5.4</b> Precision</a></li>
<li class="chapter" data-level="5.5" data-path="geommanip.html"><a href="geommanip.html#invalid"><i class="fa fa-check"></i><b>5.5</b> Generating invalid geometries</a></li>
<li class="chapter" data-level="5.6" data-path="geommanip.html"><a href="geommanip.html#longlat"><i class="fa fa-check"></i><b>5.6</b> Warnings for longitude/latitude geometries</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="featureattributes.html"><a href="featureattributes.html"><i class="fa fa-check"></i><b>6</b> Feature attributes</a><ul>
<li class="chapter" data-level="6.1" data-path="featureattributes.html"><a href="featureattributes.html#agr"><i class="fa fa-check"></i><b>6.1</b> Attribute-geometry relationships</a></li>
<li class="chapter" data-level="6.2" data-path="featureattributes.html"><a href="featureattributes.html#spatial-join"><i class="fa fa-check"></i><b>6.2</b> Spatial join</a></li>
<li class="chapter" data-level="6.3" data-path="featureattributes.html"><a href="featureattributes.html#aggregate-and-summarise"><i class="fa fa-check"></i><b>6.3</b> Aggregate and summarise</a></li>
<li class="chapter" data-level="6.4" data-path="featureattributes.html"><a href="featureattributes.html#intersections"><i class="fa fa-check"></i><b>6.4</b> Intersections</a></li>
<li class="chapter" data-level="6.5" data-path="featureattributes.html"><a href="featureattributes.html#area-weighted-interpolation"><i class="fa fa-check"></i><b>6.5</b> Area-weighted interpolation</a></li>
<li class="chapter" data-level="6.6" data-path="featureattributes.html"><a href="featureattributes.html#exercises-2"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="rs.html"><a href="rs.html"><i class="fa fa-check"></i><b>7</b> Reference Systems</a><ul>
<li class="chapter" data-level="7.1" data-path="rs.html"><a href="rs.html#units"><i class="fa fa-check"></i><b>7.1</b> Units of measurement</a></li>
<li class="chapter" data-level="7.2" data-path="rs.html"><a href="rs.html#temporal-reference-systems"><i class="fa fa-check"></i><b>7.2</b> Temporal Reference Systems</a></li>
<li class="chapter" data-level="7.3" data-path="rs.html"><a href="rs.html#crs"><i class="fa fa-check"></i><b>7.3</b> Coordinate Reference Systems</a></li>
</ul></li>
<li class="part"><span><b>II Maps</b></span></li>
<li class="chapter" data-level="8" data-path="plotting.html"><a href="plotting.html"><i class="fa fa-check"></i><b>8</b> Plotting spatial data</a><ul>
<li class="chapter" data-level="8.1" data-path="plotting.html"><a href="plotting.html#transform"><i class="fa fa-check"></i><b>8.1</b> Every plot is a projection</a></li>
<li class="chapter" data-level="8.2" data-path="plotting.html"><a href="plotting.html#plotting-points-lines-polygons-grid-cells"><i class="fa fa-check"></i><b>8.2</b> Plotting points, lines, polygons, grid cells</a></li>
<li class="chapter" data-level="8.3" data-path="plotting.html"><a href="plotting.html#class-intervals"><i class="fa fa-check"></i><b>8.3</b> Class intervals</a></li>
<li class="chapter" data-level="8.4" data-path="plotting.html"><a href="plotting.html#poles-and-datelines"><i class="fa fa-check"></i><b>8.4</b> Poles and datelines</a></li>
<li class="chapter" data-level="8.5" data-path="plotting.html"><a href="plotting.html#graticule"><i class="fa fa-check"></i><b>8.5</b> Graticules and other navigation aids</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="plot.html"><a href="plot.html"><i class="fa fa-check"></i><b>9</b> Base and grid plots</a><ul>
<li class="chapter" data-level="9.1" data-path="plot.html"><a href="plot.html#base-plots"><i class="fa fa-check"></i><b>9.1</b> Base plots</a></li>
<li class="chapter" data-level="9.2" data-path="plot.html"><a href="plot.html#combining-base-plots"><i class="fa fa-check"></i><b>9.2</b> Combining base plots</a></li>
<li class="chapter" data-level="9.3" data-path="plot.html"><a href="plot.html#grid-plots-and-viewports"><i class="fa fa-check"></i><b>9.3</b> Grid plots and viewports</a></li>
<li class="chapter" data-level="9.4" data-path="plot.html"><a href="plot.html#combining-base-and-grid-plots"><i class="fa fa-check"></i><b>9.4</b> Combining base and grid plots</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="ggplot2.html"><a href="ggplot2.html"><i class="fa fa-check"></i><b>10</b> ggplot2</a></li>
<li class="chapter" data-level="11" data-path="interactive-maps.html"><a href="interactive-maps.html"><i class="fa fa-check"></i><b>11</b> Interactive Maps</a></li>
<li class="part"><span><b>III Spatial Analysis</b></span></li>
<li class="chapter" data-level="12" data-path="summarizing-geometries.html"><a href="summarizing-geometries.html"><i class="fa fa-check"></i><b>12</b> Summarizing Geometries</a></li>
<li class="chapter" data-level="13" data-path="pp.html"><a href="pp.html"><i class="fa fa-check"></i><b>13</b> Point Pattern Analysis</a></li>
<li class="chapter" data-level="14" data-path="manipulating-attributes-summarise-aggregate-union-sample.html"><a href="manipulating-attributes-summarise-aggregate-union-sample.html"><i class="fa fa-check"></i><b>14</b> Manipulating attributes: summarise, aggregate, union, sample</a></li>
<li class="chapter" data-level="15" data-path="up-and-downscaling.html"><a href="up-and-downscaling.html"><i class="fa fa-check"></i><b>15</b> Up- and Downscaling</a></li>
<li class="chapter" data-level="16" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html"><i class="fa fa-check"></i><b>16</b> Spatial Interpolation and geostatistics</a><ul>
<li class="chapter" data-level="16.1" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#load-meuse-data"><i class="fa fa-check"></i><b>16.1</b> Load meuse data</a></li>
<li class="chapter" data-level="16.2" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#fit-variogram"><i class="fa fa-check"></i><b>16.2</b> fit variogram</a></li>
<li class="chapter" data-level="16.3" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#kriging-to-point-locations"><i class="fa fa-check"></i><b>16.3</b> kriging to point locations:</a></li>
<li class="chapter" data-level="16.4" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#kriging-to-stars-grid"><i class="fa fa-check"></i><b>16.4</b> kriging to stars grid:</a></li>
<li class="chapter" data-level="16.5" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#spatio-temporal"><i class="fa fa-check"></i><b>16.5</b> Spatio-temporal</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="area-data-and-spatial-correlation.html"><a href="area-data-and-spatial-correlation.html"><i class="fa fa-check"></i><b>17</b> Area Data and Spatial Correlation</a></li>
<li class="chapter" data-level="18" data-path="spatial-regression-and-autocorrelation.html"><a href="spatial-regression-and-autocorrelation.html"><i class="fa fa-check"></i><b>18</b> Spatial Regression and Autocorrelation</a></li>
<li class="chapter" data-level="19" data-path="movement-data.html"><a href="movement-data.html"><i class="fa fa-check"></i><b>19</b> Movement data</a></li>
<li class="chapter" data-level="20" data-path="statistical-modelling-of-spatiotemporal-data.html"><a href="statistical-modelling-of-spatiotemporal-data.html"><i class="fa fa-check"></i><b>20</b> Statistical modelling of spatiotemporal data</a></li>
<li class="chapter" data-level="21" data-path="sp-and-raster.html"><a href="sp-and-raster.html"><i class="fa fa-check"></i><b>21</b> sp and raster</a><ul>
<li class="chapter" data-level="21.1" data-path="sp-and-raster.html"><a href="sp-and-raster.html#links-and-differences-between-sf-and-sp"><i class="fa fa-check"></i><b>21.1</b> links and differences between sf and sp</a></li>
<li class="chapter" data-level="21.2" data-path="sp-and-raster.html"><a href="sp-and-raster.html#migration-packages"><i class="fa fa-check"></i><b>21.2</b> migration packages</a></li>
<li class="chapter" data-level="21.3" data-path="sp-and-raster.html"><a href="sp-and-raster.html#raster-stars-and-sf"><i class="fa fa-check"></i><b>21.3</b> raster, stars and sf</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="r-data-structures.html"><a href="r-data-structures.html"><i class="fa fa-check"></i>R data structures</a><ul>
<li class="chapter" data-level="21.4" data-path="r-data-structures.html"><a href="r-data-structures.html#homogeneous-vectors"><i class="fa fa-check"></i><b>21.4</b> Homogeneous vectors</a></li>
<li class="chapter" data-level="21.5" data-path="r-data-structures.html"><a href="r-data-structures.html#heterogeneous-vectors-list"><i class="fa fa-check"></i><b>21.5</b> Heterogeneous vectors: list</a></li>
<li class="chapter" data-level="21.6" data-path="r-data-structures.html"><a href="r-data-structures.html#attributes"><i class="fa fa-check"></i><b>21.6</b> Attributes</a></li>
<li class="chapter" data-level="21.7" data-path="r-data-structures.html"><a href="r-data-structures.html#various-names-attributes"><i class="fa fa-check"></i><b>21.7</b> various names attributes</a></li>
<li class="chapter" data-level="21.8" data-path="r-data-structures.html"><a href="r-data-structures.html#using-structure"><i class="fa fa-check"></i><b>21.8</b> using structure</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Spatial Data Science</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="geommanip" class="section level1">
<h1><span class="header-section-number">Chapter 5</span> Manipulating Geometries</h1>
<p>Simple feature geometries can be queried for properties, combined into new geometries, and combinations of geometries can be queried for properties. This chapter will give an overview of the operations offered by <code>sf</code>, entirely focusing on <em>geometrical</em> properties. The next chapter, <a href="featureattributes.html#featureattributes">6</a>, focuses on the analysis of non-geometrical feature properties, in relationship to their geometries. Some of the material in this chapter also appeared as <span class="citation">(Pebesma <a href="#ref-rjsf">2018</a><a href="#ref-rjsf">c</a>)</span>.</p>
<p>Several of the concepts of geometric manipulations were introduced in chapter @{geometries}. This chapter gives a complete listing of all geometries permitted on geometries, illustrating some of them.</p>
<p>We can categorise operations in terms of what they take as input, and what they give as output. In terms of output we have operations that give one or more</p>
<ul>
<li>predicates: a logical asserting a certain property is <code>TRUE</code>,</li>
<li>measures: a value (e.g. a numeric value with measurement unit), or</li>
<li>geometries</li>
</ul>
<p>and in terms of what they operate on, we distinguish operations that work on</p>
<ul>
<li>a single geometry (unary operations)</li>
<li>pairs of geometries (binary operations)</li>
<li>sets of geometries (n-ary operations)</li>
</ul>
<p>Before we will go through all combinations, we make two observations:</p>
<ul>
<li>most functions are implemented as methods, and operate equally on single geometry objects (<code>sfg</code>), geometry set objects (<code>sfc</code>) or simple feature (<code>sf</code>) objects.</li>
<li>also for binary and n-ary operations, <code>sfg</code> or <code>sf</code> objects are accepted as input, and taken as a set of geometries.</li>
</ul>
<div id="predicates" class="section level2">
<h2><span class="header-section-number">5.1</span> Predicates</h2>
<p>Predicates return a logical, <code>TRUE</code> or <code>FALSE</code> value, or a set of those.</p>
<div id="unary-predicates" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Unary predicates</h3>
<p><code>st_is_simple</code> returns whether a geometry is simple:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_is_simple</span>(<span class="kw">st_sfc</span>(
    <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)),
    <span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>))))) <span class="co"># self-intersects</span>
<span class="co">#&gt; [1]  TRUE FALSE</span></code></pre></div>
<p><code>st_is_valid</code> returns whether a geometry is valid</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_is_valid</span>(<span class="kw">st_sfc</span>(
    <span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))),
    <span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))))) <span class="co"># zero-length</span>
<span class="co">#&gt; [1]  TRUE FALSE</span></code></pre></div>
<p><code>st_is_empty</code> returns whether a geometry is empty</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_is_empty</span>(<span class="kw">st_point</span>())
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p><code>st_is_longlat</code> returns whether the coordinate reference system is geographic @{cs,rs}:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">demo</span>(nc, <span class="dt">ask =</span> <span class="ot">FALSE</span>, <span class="dt">echo =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; Reading layer `nc.gpkg&#39; from data source `/home/edzer/R/x86_64-pc-linux-gnu-library/3.5/sf/gpkg/nc.gpkg&#39; using driver `GPKG&#39;</span>
<span class="co">#&gt; Simple feature collection with 100 features and 14 fields</span>
<span class="co">#&gt; Attribute-geometry relationship: 0 constant, 8 aggregate, 6 identity</span>
<span class="co">#&gt; geometry type:  MULTIPOLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6</span>
<span class="co">#&gt; epsg (SRID):    4267</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=NAD27 +no_defs</span>
<span class="kw">st_is_longlat</span>(nc)
<span class="co">#&gt; [1] TRUE</span>
nc2 &lt;-<span class="st"> </span><span class="kw">st_transform</span>(nc, <span class="dv">3857</span>) <span class="co"># to web Mercator</span>
<span class="kw">st_is_longlat</span>(nc2)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">st_is_longlat</span>(<span class="kw">st_point</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">1</span>))
<span class="co">#&gt; [1] NA</span></code></pre></div>
<p><code>st_is</code> is an easy way to check for the simple feature geometry type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_is</span>(<span class="kw">st_point</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">1</span>), <span class="st">&quot;POINT&quot;</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">all</span>(<span class="kw">st_is</span>(nc, <span class="st">&quot;POLYGON&quot;</span>))
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">all</span>(<span class="kw">st_is</span>(nc, <span class="st">&quot;MULTIPOLYGON&quot;</span>))
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>Equality and inequality of geometries can be checked by <code>==</code> or <code>!=</code>; it uses geometric equality, and is insensitive to the order of traversal of nodes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">1</span>), <span class="kw">st_point</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)) <span class="op">==</span><span class="st"> </span><span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">1</span>))
<span class="co">#&gt; [1]  TRUE FALSE</span>
<span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))) <span class="op">==</span><span class="st"> </span><span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>)))
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>Under the hood, it uses <code>st_equals</code>, discussed by the binary predicates.</p>
</div>
<div id="de9im" class="section level3">
<h3><span class="header-section-number">5.1.2</span> Binary predicates</h3>
<p>Binary predicates result in a <code>TRUE</code> or <code>FALSE</code> value for every pair of inputs. For two sets of inputs with <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> geometries respectively, this results in an <span class="math inline">\(n \times m\)</span> logical matrix. Because <span class="math inline">\(n\)</span> and/or <span class="math inline">\(m\)</span> may be very large and the predicate matrix typically contains mostly <code>FALSE</code> values, a sparse representation of it, a <em>sparse geometry binary predicate</em> (<code>sgbp</code>) object, is returned by all functions. They are simply lists of indices of the <code>TRUE</code> values in each row:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(r &lt;-<span class="st"> </span><span class="kw">st_touches</span>(nc2[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>,], nc2))
<span class="co">#&gt; Sparse geometry binary predicate list of length 2, where the predicate was `touches&#39;</span>
<span class="co">#&gt;  1: 2, 18, 19</span>
<span class="co">#&gt;  2: 1, 3, 18</span>
<span class="kw">str</span>(r)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ : int [1:3] 2 18 19</span>
<span class="co">#&gt;  $ : int [1:3] 1 3 18</span>
<span class="co">#&gt;  - attr(*, &quot;predicate&quot;)= chr &quot;touches&quot;</span>
<span class="co">#&gt;  - attr(*, &quot;region.id&quot;)= chr [1:2] &quot;1&quot; &quot;2&quot;</span>
<span class="co">#&gt;  - attr(*, &quot;ncol&quot;)= int 100</span>
<span class="co">#&gt;  - attr(*, &quot;class&quot;)= chr &quot;sgbp&quot;</span></code></pre></div>
<p><code>sgbp</code> objects have the following methods:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">methods</span>(<span class="dt">class =</span> <span class="st">&#39;sgbp&#39;</span>)
<span class="co">#&gt; [1] as.data.frame as.matrix     dim           Ops           print        </span>
<span class="co">#&gt; [6] t            </span>
<span class="co">#&gt; see &#39;?methods&#39; for accessing help and source code</span></code></pre></div>
<p>For understanding predicates, the dimensionally extended 9-intersection model (DE-9IM, <span class="citation">(Clementini, Di Felice, and Oosterom <a href="#ref-de9im1">1993</a>, <span class="citation">Egenhofer and Franzosa (<a href="#ref-de9im2">1991</a>)</span>)</span>) is adopted, which is explained in more detail on <a href="https://en.wikipedia.org/wiki/DE-9IM">Wikipedia</a>. Briefly, it considers that every geometry has an interior, a boundary and an exterior. For polygons this is trivial, for points the boundary is an empty set, for linestrings the boundary is formed by the end points and the interior by all non end points. Also, any geometry has a dimension of 0 (points), 1 (lines) or 2 (polygons) or non-existent in the case of an empty geometry.</p>
<p>A relationship between two geometries A and B is expressed by the <em>dimension</em> of the overlap (intersections) of 9 intersections, formed by the 9 pairs from the interior, boundary and exterior of A, and the interior, boundary and exterior of B. We can query this relation by using <code>st_relate</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">B =<span class="st"> </span><span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>)))
A =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">0</span>)) <span class="co"># halfway the line</span>
<span class="kw">st_relate</span>(A, B)
<span class="co">#&gt;      [,1]       </span>
<span class="co">#&gt; [1,] &quot;0FFFFF102&quot;</span></code></pre></div>
<p>In the relationship found, <code>0FFFFF102</code>, <code>F</code> indicates empty geometries, and we see from</p>
<ul>
<li><code>0FF</code> that the (interior of the) point has 0-dimensional overlap with the interior of line (i.e., the overlap is a point), and no overlap with the boundary or the exterior of the line,</li>
<li><code>FFF</code> that the (empty) border of the point has nothing in common with the line, and</li>
<li><code>102</code> that the exterior of the point (all points except this one) have a 1-dimensional overlap with the interior of the line, a 0-dimensional overlap with the boundary of the line (its end points), and a 2-dimensional overlap with the exterior of the line.</li>
</ul>
<p>We can query whether a particular relationship holds by giving <code>st_relate</code> a pattern. To check for instance whether point A overlaps with an end point of linestring B, we can use</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_relate</span>(A, B, <span class="dt">pattern =</span> <span class="st">&quot;F0FFFFFFF&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.matrix</span>()
<span class="co">#&gt;       [,1]</span>
<span class="co">#&gt; [1,] FALSE</span></code></pre></div>
<p>In these patterns, <code>*</code> can be used for <em>anything</em>, and <code>T</code> for non-empty (0, 1 or 2). The standard relationships below are all expressed as particular query patterns, the Wikipedia page gives details on the patterns used.</p>
<p>The binary predicates provided by package <code>sf</code> are</p>
<table>
<colgroup>
<col width="24%" />
<col width="60%" />
<col width="15%" />
</colgroup>
<thead>
<tr class="header">
<th>predicate</th>
<th>value</th>
<th>inverse of</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>st_contains</code></td>
<td>None of the points of A are outside B</td>
<td><code>st_within</code></td>
</tr>
<tr class="even">
<td><code>st_contains_properly</code></td>
<td>A contains B and B has no points in common with the boundary of A</td>
<td></td>
</tr>
<tr class="odd">
<td><code>st_covers</code></td>
<td>No points of B lie in the exterior of A</td>
<td><code>st_covered_by</code></td>
</tr>
<tr class="even">
<td><code>st_covered_by</code></td>
<td>inverse of <code>st_covers</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>st_crosses</code></td>
<td>A and B have some but not all interior points in common</td>
<td></td>
</tr>
<tr class="even">
<td><code>st_disjoint</code></td>
<td>A and B have no points in common</td>
<td><code>st_intersects</code></td>
</tr>
<tr class="odd">
<td><code>st_equals</code></td>
<td>A and B are geometrically equal; node order number of nodes may differ; identical to A contains B AND A within B</td>
<td></td>
</tr>
<tr class="even">
<td><code>st_equals_exact</code></td>
<td>A and B are geometrically equal, and have identical node order</td>
<td></td>
</tr>
<tr class="odd">
<td><code>st_intersects</code></td>
<td>A and B are not disjoint</td>
<td><code>st_disjoint</code></td>
</tr>
<tr class="even">
<td><code>st_is_within_distance</code></td>
<td>A is closer to B than a given distance</td>
<td></td>
</tr>
<tr class="odd">
<td><code>st_within</code></td>
<td>None of the points of B are outside A</td>
<td><code>st_contains</code></td>
</tr>
<tr class="even">
<td><code>st_touches</code></td>
<td>A and B have at least one boundary point in common, but no interior points</td>
<td></td>
</tr>
<tr class="odd">
<td><code>st_overlaps</code></td>
<td>A and B have some points in common; the dimension of these is identical to that of A and B</td>
<td></td>
</tr>
<tr class="even">
<td><code>st_relate</code></td>
<td>given a pattern, returns whether A and B adhere to this pattern</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div id="n-ary" class="section level3">
<h3><span class="header-section-number">5.1.3</span> N-ary</h3>
<p>Higher-order predicates are not supported by special functions.</p>
</div>
</div>
<div id="measures" class="section level2">
<h2><span class="header-section-number">5.2</span> Measures</h2>
<div id="unary" class="section level3">
<h3><span class="header-section-number">5.2.1</span> Unary</h3>
<p>Unary measures return a single value that describes a property of the geometry:</p>
<table>
<colgroup>
<col width="25%" />
<col width="74%" />
</colgroup>
<thead>
<tr class="header">
<th><code>function</code></th>
<th>returns</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>st_dimension</code></td>
<td>0 for points, 1 for linear, 2 for polygons, <code>NA</code> for empty geometries</td>
</tr>
<tr class="even">
<td><code>st_area</code></td>
<td>the area for geometries</td>
</tr>
<tr class="odd">
<td><code>st_length</code></td>
<td>the lengths of linear geometries</td>
</tr>
<tr class="even">
<td><code>lwgeom::st_geohash</code></td>
<td>the <a href="https://en.wikipedia.org/wiki/Geohash">geohash</a> for geometries</td>
</tr>
<tr class="odd">
<td><code>st_geometry_type</code></td>
<td>the types of a set of geometries</td>
</tr>
</tbody>
</table>
</div>
<div id="binary" class="section level3">
<h3><span class="header-section-number">5.2.2</span> Binary</h3>
<p><code>st_distance</code> returns the distances between pairs of geometries, either as a vector with distances between the two first, the two second, … pairs, or as a matrix with all pairwise distances. The result is numeric, or is of class <code>units</code> <span class="citation">(Pebesma, Mailund, and Hiebert <a href="#ref-units">2016</a><a href="#ref-units">a</a>)</span> when distance units can be derived from the coordinate reference system (chapter @{rs}):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_distance</span>(nc[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,], nc[<span class="dv">2</span><span class="op">:</span><span class="dv">4</span>,], <span class="dt">by_element =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">setNames</span>(<span class="ot">NULL</span>)
<span class="co">#&gt; Units: [m]</span>
<span class="co">#&gt; [1]      0      0 367505</span>
<span class="kw">st_distance</span>(nc[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,], nc[<span class="dv">2</span><span class="op">:</span><span class="dv">4</span>,])
<span class="co">#&gt; Units: [m]</span>
<span class="co">#&gt;      [,1]  [,2]   [,3]</span>
<span class="co">#&gt; [1,]    0 25650 440513</span>
<span class="co">#&gt; [2,]    0     0 409370</span>
<span class="co">#&gt; [3,]    0     0 367505</span></code></pre></div>
<p><code>st_relate</code> returns the relation pattern, as explained in section @{de9im}, or an <code>sgbp</code> object when given a pattern template to match to.</p>
</div>
<div id="n-ary-1" class="section level3">
<h3><span class="header-section-number">5.2.3</span> N-ary</h3>
<p>No higher-order functions returning a measure are available.</p>
</div>
</div>
<div id="geometry-generating-functions" class="section level2">
<h2><span class="header-section-number">5.3</span> Geometry generating functions</h2>
<div id="unary-1" class="section level3">
<h3><span class="header-section-number">5.3.1</span> Unary</h3>
<p>Unary operations work on a per-geometry basis, and for each geometry return a new geometry. None of these functions operate on <em>more</em> than one feature geometry. Most functions are implemented as (S3) generic, with methods for <code>sfg</code>, <code>sfc</code> and <code>sf</code>; their output is of the same class as their input:</p>
<ul>
<li>for <code>sfg</code> input, an <code>sfg</code> value is returned</li>
<li>for <code>sfc</code> input, a new set of geometries is returned as <code>sfc</code></li>
<li>for <code>sf</code> objects, the same <code>sf</code> object is returned which has geometries replaced with the new ones.</li>
</ul>
<table>
<colgroup>
<col width="24%" />
<col width="75%" />
</colgroup>
<thead>
<tr class="header">
<th>function</th>
<th>returns a geometry…</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>st_centroid</code></td>
<td>of type <code>POINT</code> with the geometry’s centroid</td>
</tr>
<tr class="even">
<td><code>st_buffer</code></td>
<td>that is this larger (or smaller) than the input geometry, depending on the buffer size</td>
</tr>
<tr class="odd">
<td><code>st_jitter</code></td>
<td>that was moved in space a certain amount, using a bivariate uniform distribution</td>
</tr>
<tr class="even">
<td><code>st_wrap_dateline</code></td>
<td>cut into pieces that do no longer cover the dateline</td>
</tr>
<tr class="odd">
<td><code>st_boundary</code></td>
<td>with the boundary of the input geometry</td>
</tr>
<tr class="even">
<td><code>st_convex_hull</code></td>
<td>that forms the convex hull of the input geometry (figure <a href="geommanip.html#fig:vor">5.1</a>)</td>
</tr>
<tr class="odd">
<td><code>st_line_merge</code></td>
<td>after merging connecting <code>LINESTRING</code> elements of a <code>MULTILINESTRING</code> into longer <code>LINESTRING</code>s.</td>
</tr>
<tr class="even">
<td><code>st_make_valid</code></td>
<td>that is valid</td>
</tr>
<tr class="odd">
<td><code>st_node</code></td>
<td>with added nodes to linear geometries at intersections without a node; only works on individual linear geometries</td>
</tr>
<tr class="even">
<td><code>st_point_on_surface</code></td>
<td>with a (arbitrary) point on a surface</td>
</tr>
<tr class="odd">
<td><code>st_polygonize</code></td>
<td>of type polygon, created from lines that form a closed ring</td>
</tr>
<tr class="even">
<td><code>st_segmentize</code></td>
<td>a (linear) geometry with nodes at a given density or minimal distance</td>
</tr>
<tr class="odd">
<td><code>st_simplify</code></td>
<td>simplified by removing vertices/nodes (lines or polygons)</td>
</tr>
<tr class="even">
<td><code>lwgeom::st_split</code></td>
<td>that has been split with a splitting linestring</td>
</tr>
<tr class="odd">
<td><code>st_transform</code></td>
<td>transformed to a new coordinate reference system (chapter @{rs})</td>
</tr>
<tr class="even">
<td><code>st_triangulate</code></td>
<td>with triangulated polygon(s)</td>
</tr>
<tr class="odd">
<td><code>st_voronoi</code></td>
<td>with the voronoi tesselation of an input geometry (figure <a href="geommanip.html#fig:vor">5.1</a>)</td>
</tr>
<tr class="even">
<td><code>st_zm</code></td>
<td>with removed or added <code>Z</code> and/or <code>M</code> coordinates</td>
</tr>
<tr class="odd">
<td><code>st_collection_extract</code></td>
<td>with subgeometries from a <code>GEOMETRYCOLLECTION</code> of a particular type</td>
</tr>
<tr class="even">
<td><code>st_cast</code></td>
<td>that is converted to another type</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">4</span>), <span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))
<span class="kw">plot</span>(<span class="kw">st_geometry</span>(nc)[<span class="dv">1</span>], <span class="dt">col =</span> <span class="ot">NA</span>, <span class="dt">border =</span> <span class="st">&#39;black&#39;</span>)
<span class="kw">plot</span>(<span class="kw">st_convex_hull</span>(<span class="kw">st_geometry</span>(nc)[<span class="dv">1</span>]), <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="ot">NA</span>, <span class="dt">border =</span> <span class="st">&#39;red&#39;</span>)
<span class="kw">box</span>()
<span class="kw">set.seed</span>(<span class="dv">131</span>)
mp =<span class="st"> </span><span class="kw">st_multipoint</span>(<span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">20</span>), <span class="dv">10</span>))
<span class="kw">plot</span>(mp)
<span class="kw">plot</span>(<span class="kw">st_voronoi</span>(mp), <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="ot">NA</span>, <span class="dt">border =</span> <span class="st">&#39;red&#39;</span>)
<span class="kw">box</span>()</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:vor"></span>
<img src="sds_files/figure-html/vor-1.png" alt="left: convex hull (red) around a polygon (black); right: voronoi diagram (red) from a `MULTIPOINT` (black)" width="60%" />
<p class="caption">
Figure 5.1: left: convex hull (red) around a polygon (black); right: voronoi diagram (red) from a <code>MULTIPOINT</code> (black)
</p>
</div>
<p>A number of operation can be applied directly to geometries</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">A =</span> <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)))
<span class="co">#&gt; POINT (1 2)</span>
(<span class="dt">B =</span> <span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">4</span>))))
<span class="co">#&gt; LINESTRING (2 2, 3 4)</span>
<span class="op">-</span>A
<span class="co">#&gt; POINT (-1 -2)</span>
B <span class="op">+</span><span class="st"> </span>A
<span class="co">#&gt; LINESTRING (3 4, 4 6)</span>
<span class="kw">st_sfc</span>(B <span class="op">+</span><span class="st"> </span>A) <span class="op">*</span><span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>), <span class="dv">2</span>, <span class="dv">2</span>)
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 3 ymin: 8 xmax: 4 ymax: 12</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; LINESTRING (3 8, 4 12)</span>
<span class="kw">st_sfc</span>(A, B) <span class="op">*</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>) <span class="co"># scale first by 3, second by 5:</span>
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  GEOMETRY</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 3 ymin: 6 xmax: 15 ymax: 20</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT (3 6)</span>
<span class="co">#&gt; LINESTRING (10 10, 15 20)</span></code></pre></div>
</div>
<div id="binary-operations-returning-geometries" class="section level3">
<h3><span class="header-section-number">5.3.2</span> Binary operations returning geometries</h3>
<p>Binary functions that return a geometry include</p>
<table>
<colgroup>
<col width="21%" />
<col width="63%" />
<col width="15%" />
</colgroup>
<thead>
<tr class="header">
<th>function</th>
<th>returns</th>
<th align="center">infix operator</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>st_intersection</code></td>
<td>the overlapping geometries for pair of geometries</td>
<td align="center"><code>&amp;</code></td>
</tr>
<tr class="even">
<td><code>st_union</code></td>
<td>the combination of the geometries; also removes duplicate points, nodes or line pieces</td>
<td align="center"><code>|</code></td>
</tr>
<tr class="odd">
<td><code>st_difference</code></td>
<td>the geometries of the first after removing the overlap with the second geometry</td>
<td align="center"><code>/</code></td>
</tr>
<tr class="even">
<td><code>st_sym_differenc</code></td>
<td>the combinations of the geometries after removing where they overlap</td>
<td align="center"><code>%/%</code></td>
</tr>
</tbody>
</table>
<p>When operating on two <code>sfg</code>, single geometries, it is clear what all these functions do: return a single geometry for this pair. When given two sets of geometries (<code>sfc</code> or <code>sf</code> objects), a new set of geometries is returned; for <code>st_intersection</code> containing only the non-empty geometries, for all other operations the geometries from all pairwise evaluation. In case the arguments are of class <code>sf</code>, the attributes of the objects are copied over to all intersections to which each of the features contributed:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a =<span class="st"> </span><span class="kw">st_sf</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">geom =</span> <span class="kw">st_sfc</span>(<span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>)))))
b =<span class="st"> </span><span class="kw">st_sf</span>(<span class="dt">b =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">geom =</span> <span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>)), <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>)), <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">0</span>))))
<span class="kw">st_intersection</span>(a, b)
<span class="co">#&gt; Warning: attribute variables are assumed to be spatially constant</span>
<span class="co">#&gt; throughout all geometries</span>
<span class="co">#&gt; Simple feature collection with 2 features and 2 fields</span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 1 ymax: 0</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt;     a b        geom</span>
<span class="co">#&gt; 1   1 1 POINT (0 0)</span>
<span class="co">#&gt; 1.1 1 2 POINT (1 0)</span></code></pre></div>
<p>When <code>st_intersection</code> or <code>st_difference</code> are called with a single set of geometries (an <code>sfc</code> object), they perform an n-ary operation, explained in the next section.</p>
</div>
<div id="n-ary-operations-returning-a-geometry" class="section level3">
<h3><span class="header-section-number">5.3.3</span> N-ary operations returning a geometry</h3>
<div id="union-c-and-combine" class="section level4">
<h4><span class="header-section-number">5.3.3.1</span> Union, c, and combine</h4>
<p>Calling <code>st_union</code> with only a single argument leads either to computing the union of all geometries, or applying union to each of the individual geometries, depending on the setting of <code>by_feature</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_union</span>(b, <span class="dt">by_feature =</span> <span class="ot">FALSE</span>) <span class="co"># default</span>
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  MULTIPOINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 2 ymax: 0</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; MULTIPOINT (0 0, 1 0, 2 0)</span>
<span class="kw">st_union</span>(b, <span class="dt">by_feature =</span> <span class="ot">TRUE</span>) <span class="co"># default</span>
<span class="co">#&gt; Simple feature collection with 3 features and 1 field</span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 2 ymax: 0</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt;   b        geom</span>
<span class="co">#&gt; 1 1 POINT (0 0)</span>
<span class="co">#&gt; 2 2 POINT (1 0)</span>
<span class="co">#&gt; 3 3 POINT (2 0)</span></code></pre></div>
<p>The <code>c</code> method combines sets of geometries</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bb =<span class="st"> </span><span class="kw">st_geometry</span>(b)
<span class="kw">c</span>(bb, bb)
<span class="co">#&gt; Geometry set for 6 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 2 ymax: 0</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; First 5 geometries:</span>
<span class="co">#&gt; POINT (0 0)</span>
<span class="co">#&gt; POINT (1 0)</span>
<span class="co">#&gt; POINT (2 0)</span>
<span class="co">#&gt; POINT (0 0)</span>
<span class="co">#&gt; POINT (1 0)</span></code></pre></div>
<p>or single geometries into single a new single geometry</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="kw">st_point</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">1</span>), <span class="kw">st_point</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>))
<span class="co">#&gt; MULTIPOINT (0 1, 1 2)</span></code></pre></div>
<p>and <code>st_combine</code> uses this to collapse features for different geometries into one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_combine</span>(<span class="kw">c</span>(bb, bb))
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  MULTIPOINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 2 ymax: 0</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; MULTIPOINT (0 0, 1 0, 2 0, 0 0, 1 0, 2 0)</span></code></pre></div>
<p>When using this on lines or polygons, it is easy to obtain invalid geometries, and one needs to use <code>st_union</code> on the result.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">x =</span> <span class="kw">st_combine</span>(<span class="kw">st_sfc</span>(<span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))), <span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>),<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))))))
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  MULTILINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 1 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; MULTILINESTRING ((0 0, 1 1), (1 0, 0 1))</span>
<span class="kw">st_is_valid</span>(x)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">st_union</span>(x) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_is_valid</span>()
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
</div>
<div id="n-ary-intersection-and-difference" class="section level4">
<h4><span class="header-section-number">5.3.3.2</span> N-ary intersection and difference</h4>
<p>N-ary <code>st_intersection</code> and <code>st_difference</code> take a single argument, but operate (sequentially) on all pairs, triples, quadruples etc. Consider the plot in figure <a href="geommanip.html#fig:boxes">5.2</a>: how do we identify the box where all three overlap? Using binary intersections, as of gives us intersections of all pairs, double since <code>x</code> is passed twice: 1-1, 1-1, 1-3, 2-1, 2-2, 2-3, 3-1, 3-2, 3-3:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sq =<span class="st"> </span><span class="cf">function</span>(pt, <span class="dt">sz =</span> <span class="dv">1</span>) <span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(pt <span class="op">-</span><span class="st"> </span>sz), 
  <span class="kw">c</span>(pt[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>sz, pt[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>sz), <span class="kw">c</span>(pt <span class="op">+</span><span class="st"> </span>sz), <span class="kw">c</span>(pt[<span class="dv">1</span>] <span class="op">-</span><span class="st"> </span>sz, pt[<span class="dv">2</span>] <span class="op">+</span><span class="st"> </span>sz), <span class="kw">c</span>(pt <span class="op">-</span><span class="st"> </span>sz))))
x =<span class="st"> </span><span class="kw">st_sf</span>(<span class="dt">box =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="kw">st_sfc</span>(<span class="kw">sq</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>)), <span class="kw">sq</span>(<span class="kw">c</span>(<span class="fl">1.7</span>, <span class="fl">-0.5</span>)), <span class="kw">sq</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>))))
(<span class="dt">ixx =</span> <span class="kw">st_intersection</span>(x, x)) <span class="op">%&gt;%</span><span class="st"> </span>nrow
<span class="co">#&gt; Warning: attribute variables are assumed to be spatially constant</span>
<span class="co">#&gt; throughout all geometries</span>
<span class="co">#&gt; [1] 9</span>
<span class="kw">lengths</span>(<span class="kw">st_overlaps</span>(ixx, ixx))
<span class="co">#&gt; [1] 4 5 5 5 4 5 5 5 4</span></code></pre></div>
<p>When we use however</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">i =</span> <span class="kw">st_intersection</span>(x))
<span class="co">#&gt; Simple feature collection with 7 features and 3 fields</span>
<span class="co">#&gt; geometry type:  POLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -1 ymin: -1.5 xmax: 2.7 ymax: 2</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt;   box                       geometry n.overlaps origins</span>
<span class="co">#&gt; 1   1 POLYGON ((0.7 -1, -1 -1, -1...          1       1</span>
<span class="co">#&gt; 2   1 POLYGON ((1 0, 1 -1, 0.7 -1...          2    1, 2</span>
<span class="co">#&gt; 3   2 POLYGON ((1.5 0.5, 2.7 0.5,...          1       2</span>
<span class="co">#&gt; 4   2 POLYGON ((1 0.5, 1.5 0.5, 1...          2    2, 3</span>
<span class="co">#&gt; 5   1 POLYGON ((1 0.5, 1 0, 0.7 0...          3 1, 2, 3</span>
<span class="co">#&gt; 6   1 POLYGON ((-0.5 1, 1 1, 1 0....          2    1, 3</span>
<span class="co">#&gt; 7   3 POLYGON ((-0.5 1, -0.5 2, 1...          1       3</span></code></pre></div>
<p>we end up with a set of all seven distinct intersections, without overlaps.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lengths</span>(<span class="kw">st_overlaps</span>(i, i))
<span class="co">#&gt; [1] 0 0 0 0 0 0 0</span></code></pre></div>
<p>When given an <code>sf</code> object an <code>sf</code> is returned, with two additional fields, one with the number of overlapping features, and a list-column with the indexes of contributing feature geometries.</p>
<div class="figure" style="text-align: center"><span id="fig:boxes"></span>
<img src="sds_files/figure-html/boxes-1.png" alt="left: three overlapping boxes -- how do we identify the small box where all three overlap? right: unique, non-overlapping n-ary intersections" width="50%" />
<p class="caption">
Figure 5.2: left: three overlapping boxes – how do we identify the small box where all three overlap? right: unique, non-overlapping n-ary intersections
</p>
</div>
<p>Similarly, one can compute n-ary differences from a set <span class="math inline">\(\{s_1, s_2, s_3, ...\}\)</span> by creating differences <span class="math inline">\(\{s_1, s_2-s_1, s_3-s_2-s_1, ...\}\)</span>. This is done by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">xd =</span> <span class="kw">st_difference</span>(x))
<span class="co">#&gt; Simple feature collection with 3 features and 1 field</span>
<span class="co">#&gt; geometry type:  POLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -1 ymin: -1.5 xmax: 2.7 ymax: 2</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt;   box                       geometry</span>
<span class="co">#&gt; 1   1 POLYGON ((-1 -1, 1 -1, 1 1,...</span>
<span class="co">#&gt; 2   2 POLYGON ((1 0.5, 2.7 0.5, 2...</span>
<span class="co">#&gt; 3   3 POLYGON ((-0.5 1, -0.5 2, 1...</span></code></pre></div>
<p>The result is shown in figure <a href="geommanip.html#fig:diff">5.3</a>, for <code>x</code> and for <code>x[3:1]</code>, to make clear that the result here depends on order of the geometries.</p>
<div class="figure" style="text-align: center"><span id="fig:diff"></span>
<img src="sds_files/figure-html/diff-1.png" alt="difference between subsequent boxes, left: in original order; right: in reverse order" width="50%" />
<p class="caption">
Figure 5.3: difference between subsequent boxes, left: in original order; right: in reverse order
</p>
</div>
<p>Resulting geometries do not overlap:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lengths</span>(<span class="kw">st_overlaps</span>(xd, xd))
<span class="co">#&gt; [1] 0 0 0</span></code></pre></div>
</div>
</div>
<div id="other-geometry-manipulators" class="section level3">
<h3><span class="header-section-number">5.3.4</span> Other geometry manipulators</h3>
<p><code>st_make_grid</code> creates a grid of square or hexagonal polygons, based on an input bounding box and a grid cell size.</p>
<p><code>st_graticule</code> creates a set of graticules, lines of constant latitude or longitude, which can serve as a reference on small-scale (large area) maps.</p>
</div>
</div>
<div id="precision" class="section level2">
<h2><span class="header-section-number">5.4</span> Precision</h2>
<p>Geometrical operations, such as finding out whether a certain point is on a line, may fail when coordinates are represented by highly precise floating point numbers, such as 8-byte doubles in R. A remedy might be to limit the precision of the coordinates before the operation. For this, a <em>precision model</em> is adopted by <code>sf</code>. It uses a precision value to round coordinates (X, Y, Z and M) right before they are encoded as well-known binary, and passed on to the libraries where this may have an effect (GEOS, GDAL, liblwgeom). We demonstrate this by an R - WKB - R roundtrip.</p>
<p>Rounding can be done in two different ways. First, With a negative precision value, 8-byte doubles get converted to 4-byte floats and back again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">p =</span> <span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="fl">1e6</span><span class="op">/</span><span class="dv">3</span>, <span class="fl">1e4</span><span class="op">/</span><span class="dv">3</span>)), <span class="dt">crs =</span> <span class="dv">3857</span>))
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 333000 ymin: 3330 xmax: 333000 ymax: 3330</span>
<span class="co">#&gt; epsg (SRID):    3857</span>
<span class="co">#&gt; proj4string:    +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs</span>
<span class="co">#&gt; POINT (333333 3333)</span>
p <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_set_precision</span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_binary</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_sfc</span>() <span class="op">%&gt;%</span><span class="st"> `</span><span class="dt">[[</span><span class="st">`</span>(<span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">digits =</span> <span class="dv">16</span>)
<span class="co">#&gt; POINT (333333.34375 3333.333251953125)</span></code></pre></div>
<p>Second, with a positive precision <span class="math inline">\(p\)</span>, each coordinate value <span class="math inline">\(c\)</span> is replaced by <span class="math display">\[c&#39; = \mbox{round}(p \cdot c) / p\]</span> This implies that for instance with a precision of 1000, the number of decimal places to round to is 1/1000, or to mm if the unit of coordinates is metre:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_set_precision</span>(<span class="dv">1000</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_binary</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_sfc</span>() <span class="op">%&gt;%</span><span class="st"> `</span><span class="dt">[[</span><span class="st">`</span>(<span class="dv">1</span>)
<span class="co">#&gt; POINT (333333 3333)</span></code></pre></div>
<p>With a precision of e.g. 0.001 or 0.05, rounding to the nearest <code>1/precision</code>, i.e. if the unit is m to the nearest 1000 m or 20 m, is obtained:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_set_precision</span>(<span class="fl">0.001</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_binary</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_sfc</span>() <span class="op">%&gt;%</span><span class="st"> `</span><span class="dt">[[</span><span class="st">`</span>(<span class="dv">1</span>) <span class="co"># to nearest 1000</span>
<span class="co">#&gt; POINT (333000 3000)</span>
p <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_set_precision</span>(<span class="fl">0.05</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_binary</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_sfc</span>()  <span class="op">%&gt;%</span><span class="st"> `</span><span class="dt">[[</span><span class="st">`</span>(<span class="dv">1</span>) <span class="co"># to nearest 20</span>
<span class="co">#&gt; POINT (333340 3340)</span></code></pre></div>
<p>As a convenience, precisions can also be specified as a <code>units</code> object, with the unit to round to, e.g. to the nearest 5 cm:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_set_precision</span>(units<span class="op">::</span><span class="kw">set_units</span>(<span class="dv">5</span>, cm)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">st_as_binary</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">st_as_sfc</span>() <span class="op">%&gt;%</span><span class="st"> `</span><span class="dt">[[</span><span class="st">`</span>(<span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">print</span>(<span class="dt">digits =</span> <span class="dv">10</span>)
<span class="co">#&gt; POINT (333333.35 3333.35)</span></code></pre></div>
<p>but this requires that the object, <code>p</code>, has a coordinate reference system with known units.</p>
<p>In essence, these rounding methods bring the coordinates to points on a regular grid, which is beneficial for geometric computations. Of course, it also affects all computations like areas and distances. Which precision values are best for which application is often a matter of common sense combined with trial and error. A reproducible example illustrating the need for setting precision is found <a href="https://github.com/r-spatial/sf/issues/275">here</a>.</p>
</div>
<div id="invalid" class="section level2">
<h2><span class="header-section-number">5.5</span> Generating invalid geometries</h2>
<p>It is rather easy to have <code>st_intersection</code> generate invalid geometries, resulting in an error. Consider the graph constructed and shown in figure <a href="geommanip.html#fig:invalid">5.4</a>. In this case, <em>not</em> setting the precision (i.e., precision has value 0) would have led to the cryptic error message</p>
<pre><code>Error in CPL_nary_intersection(x) :
  Evaluation error: TopologyException: found non-noded intersection between 
  LINESTRING (0.329035 -0.0846201, 0.333671 -0.0835073) and 
  LINESTRING (0.330465 -0.0842769, 0.328225 -0.0848146) 
  at 0.32965918719530368 -0.084470389572422672.
Calls: st_intersection ... st_intersection -&gt; st_intersection.sfc -&gt; CPL_nary_intersection</code></pre>
<p>However, with zero precision and a <code>buf_size</code> of 0.7 we will <em>not</em> get this error.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n =<span class="st"> </span><span class="dv">12</span> <span class="co"># n points, equally spread along unit circle:</span>
pts =<span class="st"> </span>(<span class="dv">1</span><span class="op">:</span>n)<span class="op">/</span>n <span class="op">*</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>pi 
xy =<span class="st"> </span><span class="kw">st_as_sf</span>(<span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">cos</span>(pts), <span class="dt">y =</span> <span class="kw">sin</span>(pts)), <span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>))
buf_size =<span class="st"> </span><span class="fl">0.8</span>
precision =<span class="st"> </span><span class="dv">1000</span>
b =<span class="st"> </span><span class="kw">st_buffer</span>(xy, buf_size)
i =<span class="st"> </span><span class="kw">st_intersection</span>(<span class="kw">st_set_precision</span>(b, precision))
<span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">4</span>))
<span class="kw">plot</span>(i[<span class="dv">1</span>], <span class="dt">col =</span> <span class="kw">sf.colors</span>(<span class="kw">nrow</span>(i), <span class="dt">categorical =</span> <span class="ot">TRUE</span>))
<span class="kw">all</span>(<span class="kw">st_is_valid</span>(i))
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:invalid"></span>
<img src="sds_files/figure-html/invalid-1.png" alt="n-ary intersection that may lead to invalid geometries" width="60%" />
<p class="caption">
Figure 5.4: n-ary intersection that may lead to invalid geometries
</p>
</div>
</div>
<div id="longlat" class="section level2">
<h2><span class="header-section-number">5.6</span> Warnings for longitude/latitude geometries</h2>
<p>When working on geodetic coordinates (degrees longitude/latitude), package <code>sf</code> gives warnings when it makes the assumption that coordinates are Cartesian, e.g. in</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">i =<span class="st"> </span><span class="kw">st_intersects</span>(nc[<span class="dv">1</span>,], nc[<span class="dv">2</span>,])
<span class="co">#&gt; although coordinates are longitude/latitude, st_intersects assumes that they are planar</span></code></pre></div>
<p>In many cases, making this assumption is not a problem. It might be a problem when we have polygons that cover very large areas, cover North or South pole, or have lines crossing or polygons covering the dateline.</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-rjsf">
<p>Pebesma, Edzer. 2018c. “Simple Features for R: Standardized Support for Spatial Vector Data.” <em>The R Journal</em> 10 (1): 439–46. <a href=" https://journal.r-project.org/archive/2018/RJ-2018-009/index.html ">https://journal.r-project.org/archive/2018/RJ-2018-009/index.html</a>.</p>
</div>
<div id="ref-de9im1">
<p>Clementini, Eliseo, Paolino Di Felice, and Peter van Oosterom. 1993. “A Small Set of Formal Topological Relationships Suitable for End-User Interaction.” In <em>Advances in Spatial Databases</em>, edited by David Abel and Beng Chin Ooi, 277–95. Berlin, Heidelberg: Springer Berlin Heidelberg.</p>
</div>
<div id="ref-de9im2">
<p>Egenhofer, Max J., and Robert D. Franzosa. 1991. “Point-Set Topological Spatial Relations.” <em>International Journal of Geographical Information Systems</em> 5 (2). Taylor &amp; Francis: 161–74. doi:<a href="https://doi.org/10.1080/02693799108927841">10.1080/02693799108927841</a>.</p>
</div>
<div id="ref-units">
<p>Pebesma, Edzer, Thomas Mailund, and James Hiebert. 2016a. “Measurement Units in R.” <em>The R Journal</em> 8 (2): 486–94. doi:<a href="https://doi.org/10.32614/RJ-2016-061">10.32614/RJ-2016-061</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="raster.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="featureattributes.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/edzer/sdsr/edit/master/05-GeomManipulations.Rmd",
"text": "Edit"
},
"download": ["sds.pdf", "sds.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
