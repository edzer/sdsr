<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Spatial Data Science with R</title>
  <meta name="description" content="description_xx">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Spatial Data Science with R" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="description_xx" />
  <meta name="github-repo" content="edzer/sdsr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Spatial Data Science with R" />
  
  <meta name="twitter:description" content="description_xx" />
  

<meta name="author" content="Edzer Pebesma, Roger Bivand">


<meta name="date" content="2018-12-17">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="cs.html">
<link rel="next" href="raster.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-1.2/htmlwidgets.js"></script>
<link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-1.3.1/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<script src="libs/Proj4Leaflet-1.0.1/proj4-compressed.js"></script>
<script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script>
<link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-binding-2.0.2/leaflet.js"></script>
<script src="libs/leaflet-providers-1.1.17/leaflet-providers.js"></script>
<script src="libs/leaflet-providers-plugin-2.0.2/leaflet-providers-plugin.js"></script>
<link href="libs/HomeButton-0.0.1/home-button.css" rel="stylesheet" />
<script src="libs/HomeButton-0.0.1/home-button.js"></script>
<script src="libs/HomeButton-0.0.1/easy-button-src.min.js"></script>
<link href="libs/PopupTable-0.0.1/popup.css" rel="stylesheet" />


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Spatial Data Science with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="part"><span><b>I Spatial Data</b></span></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Getting Started</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#a-first-map"><i class="fa fa-check"></i><b>1.1</b> A first map</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#reading"><i class="fa fa-check"></i><b>1.2</b> Reading and writing</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.3</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="cs.html"><a href="cs.html"><i class="fa fa-check"></i><b>2</b> Coordinate systems</a><ul>
<li class="chapter" data-level="2.1" data-path="cs.html"><a href="cs.html#cartesian-and-geodetic-coordinates"><i class="fa fa-check"></i><b>2.1</b> Cartesian and geodetic coordinates</a></li>
<li class="chapter" data-level="2.2" data-path="cs.html"><a href="cs.html#ellipsoidal-coordinates"><i class="fa fa-check"></i><b>2.2</b> Ellipsoidal coordinates</a></li>
<li class="chapter" data-level="2.3" data-path="cs.html"><a href="cs.html#distances"><i class="fa fa-check"></i><b>2.3</b> Distances</a></li>
<li class="chapter" data-level="2.4" data-path="cs.html"><a href="cs.html#bounded-spaces"><i class="fa fa-check"></i><b>2.4</b> Bounded spaces</a></li>
<li class="chapter" data-level="2.5" data-path="cs.html"><a href="cs.html#time"><i class="fa fa-check"></i><b>2.5</b> Time</a></li>
<li class="chapter" data-level="2.6" data-path="cs.html"><a href="cs.html#exercises-1"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="geometries.html"><a href="geometries.html"><i class="fa fa-check"></i><b>3</b> Geometries</a><ul>
<li class="chapter" data-level="3.1" data-path="geometries.html"><a href="geometries.html#simple-feature-geometry-types"><i class="fa fa-check"></i><b>3.1</b> Simple feature geometry types</a></li>
<li class="chapter" data-level="3.2" data-path="geometries.html"><a href="geometries.html#simple-features-in-sf"><i class="fa fa-check"></i><b>3.2</b> Simple features in <code>sf</code></a></li>
<li class="chapter" data-level="3.3" data-path="geometries.html"><a href="geometries.html#geomraster"><i class="fa fa-check"></i><b>3.3</b> Tesselations: coverages, rasters</a></li>
<li class="chapter" data-level="3.4" data-path="geometries.html"><a href="geometries.html#networks"><i class="fa fa-check"></i><b>3.4</b> Networks</a></li>
<li class="chapter" data-level="3.5" data-path="geometries.html"><a href="geometries.html#geometries-on-the-sphere"><i class="fa fa-check"></i><b>3.5</b> Geometries on the sphere</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="raster.html"><a href="raster.html"><i class="fa fa-check"></i><b>4</b> Raster and vector datacubes</a><ul>
<li class="chapter" data-level="4.1" data-path="raster.html"><a href="raster.html#package-stars"><i class="fa fa-check"></i><b>4.1</b> Package <code>stars</code></a></li>
<li class="chapter" data-level="4.2" data-path="raster.html"><a href="raster.html#raster-data"><i class="fa fa-check"></i><b>4.2</b> Raster data</a></li>
<li class="chapter" data-level="4.3" data-path="raster.html"><a href="raster.html#datacubes"><i class="fa fa-check"></i><b>4.3</b> Vector Datacubes</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="geommanip.html"><a href="geommanip.html"><i class="fa fa-check"></i><b>5</b> Manipulating Geometries</a><ul>
<li class="chapter" data-level="5.1" data-path="geommanip.html"><a href="geommanip.html#predicates"><i class="fa fa-check"></i><b>5.1</b> Predicates</a></li>
<li class="chapter" data-level="5.2" data-path="geommanip.html"><a href="geommanip.html#measures"><i class="fa fa-check"></i><b>5.2</b> Measures</a></li>
<li class="chapter" data-level="5.3" data-path="geommanip.html"><a href="geommanip.html#geometry-generating-functions"><i class="fa fa-check"></i><b>5.3</b> Geometry generating functions</a></li>
<li class="chapter" data-level="5.4" data-path="geommanip.html"><a href="geommanip.html#precision"><i class="fa fa-check"></i><b>5.4</b> Precision</a></li>
<li class="chapter" data-level="5.5" data-path="geommanip.html"><a href="geommanip.html#longlat"><i class="fa fa-check"></i><b>5.5</b> Warnings for longitude/latitude geometries</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="featureattributes.html"><a href="featureattributes.html"><i class="fa fa-check"></i><b>6</b> Feature attributes</a><ul>
<li class="chapter" data-level="6.1" data-path="featureattributes.html"><a href="featureattributes.html#agr"><i class="fa fa-check"></i><b>6.1</b> Attribute-geometry relationship</a></li>
<li class="chapter" data-level="6.2" data-path="featureattributes.html"><a href="featureattributes.html#spatial-join"><i class="fa fa-check"></i><b>6.2</b> Spatial join</a></li>
<li class="chapter" data-level="6.3" data-path="featureattributes.html"><a href="featureattributes.html#aggregate-and-summarise"><i class="fa fa-check"></i><b>6.3</b> Aggregate and summarise</a></li>
<li class="chapter" data-level="6.4" data-path="featureattributes.html"><a href="featureattributes.html#intersections"><i class="fa fa-check"></i><b>6.4</b> Intersections</a></li>
<li class="chapter" data-level="6.5" data-path="featureattributes.html"><a href="featureattributes.html#area-weighted-interpolation"><i class="fa fa-check"></i><b>6.5</b> Area-weighted interpolation</a></li>
<li class="chapter" data-level="6.6" data-path="featureattributes.html"><a href="featureattributes.html#exercises-2"><i class="fa fa-check"></i><b>6.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="rs.html"><a href="rs.html"><i class="fa fa-check"></i><b>7</b> Reference Systems</a><ul>
<li class="chapter" data-level="7.1" data-path="rs.html"><a href="rs.html#units"><i class="fa fa-check"></i><b>7.1</b> Units of measurement</a></li>
<li class="chapter" data-level="7.2" data-path="rs.html"><a href="rs.html#temporal-reference-systems"><i class="fa fa-check"></i><b>7.2</b> Temporal Reference Systems</a></li>
<li class="chapter" data-level="7.3" data-path="rs.html"><a href="rs.html#crs"><i class="fa fa-check"></i><b>7.3</b> Coordinate Reference Systems</a></li>
</ul></li>
<li class="part"><span><b>II Maps</b></span></li>
<li class="chapter" data-level="8" data-path="plotting-spatial-data.html"><a href="plotting-spatial-data.html"><i class="fa fa-check"></i><b>8</b> Plotting spatial data</a></li>
<li class="chapter" data-level="9" data-path="plot.html"><a href="plot.html"><i class="fa fa-check"></i><b>9</b> Base Plot</a></li>
<li class="chapter" data-level="10" data-path="ggplot2.html"><a href="ggplot2.html"><i class="fa fa-check"></i><b>10</b> ggplot2</a></li>
<li class="chapter" data-level="11" data-path="interactive-maps.html"><a href="interactive-maps.html"><i class="fa fa-check"></i><b>11</b> Interactive Maps</a></li>
<li class="part"><span><b>III Spatial Analysis</b></span></li>
<li class="chapter" data-level="12" data-path="summarizing-geometries.html"><a href="summarizing-geometries.html"><i class="fa fa-check"></i><b>12</b> Summarizing Geometries</a></li>
<li class="chapter" data-level="13" data-path="point-pattern-analysis.html"><a href="point-pattern-analysis.html"><i class="fa fa-check"></i><b>13</b> Point Pattern Analysis</a></li>
<li class="chapter" data-level="14" data-path="manipulating-attributes-summarise-aggregate-union-sample.html"><a href="manipulating-attributes-summarise-aggregate-union-sample.html"><i class="fa fa-check"></i><b>14</b> Manipulating attributes: summarise, aggregate, union, sample</a></li>
<li class="chapter" data-level="15" data-path="units-of-measure-revisited-attribute-units-intensive-and-extensive-variables.html"><a href="units-of-measure-revisited-attribute-units-intensive-and-extensive-variables.html"><i class="fa fa-check"></i><b>15</b> Units of measure revisited: attribute units, intensive and extensive variables</a></li>
<li class="chapter" data-level="16" data-path="up-and-downscaling.html"><a href="up-and-downscaling.html"><i class="fa fa-check"></i><b>16</b> Up- and Downscaling</a></li>
<li class="chapter" data-level="17" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html"><i class="fa fa-check"></i><b>17</b> Spatial Interpolation and geostatistics</a><ul>
<li class="chapter" data-level="17.1" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#load-meuse-data"><i class="fa fa-check"></i><b>17.1</b> Load meuse data</a></li>
<li class="chapter" data-level="17.2" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#fit-variogram"><i class="fa fa-check"></i><b>17.2</b> fit variogram</a></li>
<li class="chapter" data-level="17.3" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#kriging-to-point-locations"><i class="fa fa-check"></i><b>17.3</b> kriging to point locations:</a></li>
<li class="chapter" data-level="17.4" data-path="spatial-interpolation-and-geostatistics.html"><a href="spatial-interpolation-and-geostatistics.html#kriging-to-stars-grid"><i class="fa fa-check"></i><b>17.4</b> kriging to stars grid:</a></li>
</ul></li>
<li class="chapter" data-level="18" data-path="area-data-and-spatial-correlation.html"><a href="area-data-and-spatial-correlation.html"><i class="fa fa-check"></i><b>18</b> Area Data and Spatial Correlation</a></li>
<li class="chapter" data-level="19" data-path="spatial-regression-and-autocorrelation.html"><a href="spatial-regression-and-autocorrelation.html"><i class="fa fa-check"></i><b>19</b> Spatial Regression and Autocorrelation</a></li>
<li class="chapter" data-level="20" data-path="raster-modelling.html"><a href="raster-modelling.html"><i class="fa fa-check"></i><b>20</b> Raster Modelling</a></li>
<li class="chapter" data-level="21" data-path="movement-data.html"><a href="movement-data.html"><i class="fa fa-check"></i><b>21</b> Movement data</a></li>
<li class="chapter" data-level="22" data-path="statistical-modelling-of-spatiotemporal-data.html"><a href="statistical-modelling-of-spatiotemporal-data.html"><i class="fa fa-check"></i><b>22</b> Statistical modelling of spatiotemporal data</a></li>
<li class="chapter" data-level="23" data-path="scalability.html"><a href="scalability.html"><i class="fa fa-check"></i><b>23</b> Scalability</a><ul>
<li class="chapter" data-level="23.1" data-path="scalability.html"><a href="scalability.html#out-of-memory"><i class="fa fa-check"></i><b>23.1</b> Out-of-memory</a></li>
<li class="chapter" data-level="23.2" data-path="scalability.html"><a href="scalability.html#out-of-core"><i class="fa fa-check"></i><b>23.2</b> Out-of-core</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="r-data-structures.html"><a href="r-data-structures.html"><i class="fa fa-check"></i>R data structures</a><ul>
<li class="chapter" data-level="23.3" data-path="r-data-structures.html"><a href="r-data-structures.html#homogeneous-vectors"><i class="fa fa-check"></i><b>23.3</b> Homogeneous vectors</a></li>
<li class="chapter" data-level="23.4" data-path="r-data-structures.html"><a href="r-data-structures.html#heterogeneous-vectors-list"><i class="fa fa-check"></i><b>23.4</b> Heterogeneous vectors: list</a></li>
<li class="chapter" data-level="23.5" data-path="r-data-structures.html"><a href="r-data-structures.html#attributes"><i class="fa fa-check"></i><b>23.5</b> Attributes</a></li>
<li class="chapter" data-level="23.6" data-path="r-data-structures.html"><a href="r-data-structures.html#various-names-attributes"><i class="fa fa-check"></i><b>23.6</b> various names attributes</a></li>
<li class="chapter" data-level="23.7" data-path="r-data-structures.html"><a href="r-data-structures.html#using-structure"><i class="fa fa-check"></i><b>23.7</b> using structure</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Spatial Data Science with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="geometries" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Geometries</h1>
<p>Having learned how we describe spaces, we can define how geometries can be described in these space. This chapter will mostly explain the geometries for <em>simple features</em>, and introduce the three classes <code>sfg</code>, <code>sfc</code> and <code>sf</code> for single geometries, geometry sets, and geometry sets with associated attributes.</p>
<div id="simple-feature-geometry-types" class="section level2">
<h2><span class="header-section-number">3.1</span> Simple feature geometry types</h2>
<p>Simple feature geometries are a way to describe the geometries of <em>features</em>. By <em>features</em> we mean <em>things</em> that have a geometry, some time properties, and other attributes. The main application of simple feature geometries is to describe two-dimensional geometries by points, lines, or polygons. The “simple” adjective refers to the fact that the line or polygon geometries are represented by sequences of points connected with straight lines.</p>
<p><em>Simple features access</em> is a standard <span class="citation">(Herring <a href="#ref-sfa">2011</a>, <span class="citation">Herring (<a href="#ref-sfa2">2010</a>)</span>, <span class="citation">ISO (<a href="#ref-iso">2004</a>)</span>)</span> for describing simple feature geometries that includes</p>
<ul>
<li>a class hierarchy</li>
<li>a set of operations</li>
<li>binary and text encodings</li>
</ul>
<p>We will now discuss the seven most common simple feature geometry types. Although in practice we will most often import spatial data from external sources (files, databases, web services), we will create them here from scratch using simple constructor functions.</p>
<div id="the-big-seven" class="section level3">
<h3><span class="header-section-number">3.1.1</span> The big seven</h3>
<p>The most commonly used simple features geometries, used to represent a <em>single</em> feature are:</p>
<table>
<colgroup>
<col width="8%" />
<col width="91%" />
</colgroup>
<thead>
<tr class="header">
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>POINT</code></td>
<td>single point geometry</td>
</tr>
<tr class="even">
<td><code>MULTIPOINT</code></td>
<td>set of points</td>
</tr>
<tr class="odd">
<td><code>LINESTRING</code></td>
<td>single linestring (two or more points connected by straight lines)</td>
</tr>
<tr class="even">
<td><code>MULTILINESTRING</code></td>
<td>set of linestrings</td>
</tr>
<tr class="odd">
<td><code>POLYGON</code></td>
<td>exterior ring with zero or more inner rings, denoting holes</td>
</tr>
<tr class="even">
<td><code>MULTIPOLYGON</code></td>
<td>set of polygons</td>
</tr>
<tr class="odd">
<td><code>GEOMETRYCOLLECTION</code></td>
<td>set of the geometries above</td>
</tr>
</tbody>
</table>
<p>Points in a geometry contain at least two coordinates: x and y, in that order.</p>
</div>
<div id="valid-geometries" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Valid geometries</h3>
<p>Valid geometries obey the following properties:</p>
<ul>
<li>linestrings shall not self-intersect</li>
<li>polygon rings shall be closed (the last point equals the first)</li>
<li>polygon holes (inner rings) shall be inside their exterior ring</li>
<li>polygon inner rings shall maximally touch the exterior ring in single points, not over a line</li>
<li>a polygon ring shall not repeat its own path</li>
</ul>
<p>If this is not the case, the geometry concerned is not valid.</p>
</div>
<div id="z-and-m" class="section level3">
<h3><span class="header-section-number">3.1.3</span> Z and M</h3>
<p>In addition to X and Y coordinates, Single points (vertices) of simple feature geometries can have</p>
<ul>
<li>a <code>Z</code> coordinate, denoting altitude, and/or</li>
<li>an <code>M</code> value, denoting some “measure”</li>
</ul>
<p>The <code>M</code> attribute shall be a property of the vertex. It sounds attractive to encode a time stamp in it, e.g. to pack trajectories in <code>LINESTRING</code>s. These become however invalid once the trajectory self-intersects.</p>
<p>Both <code>Z</code> and <code>M</code> are found relatively rarely, and software support to do something useful with them is (still) rather rare.</p>
</div>
<div id="ten-further-geometry-types" class="section level3">
<h3><span class="header-section-number">3.1.4</span> Ten further geometry types</h3>
<p>There are 10 more geometry types which are more rare, but increasingly find implementation:</p>
<table style="width:78%;">
<colgroup>
<col width="6%" />
<col width="70%" />
</colgroup>
<thead>
<tr class="header">
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>CIRCULARSTRING</code></td>
<td>The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the linear world. A single segment requires three points, the start and end points (first and third) and any other point on the arc. The exception to this is for a closed circle, where the start and end points are the same. In this case the second point MUST be the center of the arc, ie the opposite side of the circle. To chain arcs together, the last point of the previous arc becomes the first point of the next arc, just like in LINESTRING. This means that a valid circular string must have an odd number of points greated than 1.</td>
</tr>
<tr class="even">
<td><code>COMPOUNDCURVE</code></td>
<td>A compound curve is a single, continuous curve that has both curved (circular) segments and linear segments. That means that in addition to having well-formed components, the end point of every component (except the last) must be coincident with the start point of the following component.</td>
</tr>
<tr class="odd">
<td><code>CURVEPOLYGON</code></td>
<td>Example compound curve in a curve polygon: CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )</td>
</tr>
<tr class="even">
<td><code>MULTICURVE</code></td>
<td>A MultiCurve is a 1-dimensional GeometryCollection whose elements are Curves, it can include linear strings, circular strings or compound strings.</td>
</tr>
<tr class="odd">
<td><code>MULTISURFACE</code></td>
<td>A MultiSurface is a 2-dimensional GeometryCollection whose elements are Surfaces, all using coordinates from the same coordinate reference system.</td>
</tr>
<tr class="even">
<td><code>CURVE</code></td>
<td>A Curve is a 1-dimensional geometric object usually stored as a sequence of Points, with the subtype of Curve specifying the form of the interpolation between Points</td>
</tr>
<tr class="odd">
<td><code>SURFACE</code></td>
<td>A Surface is a 2-dimensional geometric object</td>
</tr>
<tr class="even">
<td><code>POLYHEDRALSURFACE</code></td>
<td>A PolyhedralSurface is a contiguous collection of polygons, which share common boundary segments</td>
</tr>
<tr class="odd">
<td><code>TIN</code></td>
<td>A TIN (triangulated irregular network) is a PolyhedralSurface consisting only of Triangle patches.</td>
</tr>
<tr class="even">
<td><code>TRIANGLE</code></td>
<td>A Triangle is a polygon with 3 distinct, non-collinear vertices and no interior boundary</td>
</tr>
</tbody>
</table>
<p>Note that <code>CIRCULASTRING</code>, <code>COMPOUNDCURVE</code> and <code>CURVEPOLYGON</code> are not described in the SFA standard, but in the <a href="https://www.iso.org/standard/38651.html">SQL-MM part 3 standard</a>. The descriptions above were copied from the <a href="http://postgis.net/docs/using_postgis_dbmanagement.html">PostGIS manual</a>.</p>
</div>
<div id="encodings" class="section level3">
<h3><span class="header-section-number">3.1.5</span> Encodings</h3>
<p>Part of the simple feature standard are two encodings: a text and a binary encoding. The text strings <code>POINT (0 1)</code> and so on indicate text encodings, also known as <em>well-known text</em> (WKT) encodings, of simple feature geometries. They are meant to be human-readable.</p>
</div>
</div>
<div id="simple-features-in-sf" class="section level2">
<h2><span class="header-section-number">3.2</span> Simple features in <code>sf</code></h2>
<p>This section describes the implementation of simple feature geometries in package <code>sf</code>. It will first explain how single simple feature geometries, explained in the previous section, are represented in R objects of class <code>sfg</code>. Next, it will explain how <em>sets</em> of simple feature geometry objects are collected in a list of class <code>sfc</code>. This list acts as a geometry <em>list-column</em> in data.frame objects, of class <code>sf</code>.</p>
<div id="sfg-simple-feature-geometry" class="section level3">
<h3><span class="header-section-number">3.2.1</span> <code>sfg</code>: simple feature geometry</h3>
<p>Point sets are stored as numeric matrix, with 2 (<code>XY</code>), 3 (<code>XYZ</code> or <code>XYM</code>) or 4 (<code>XYZM</code>) columns, with a points in each row. Individual simple feature geometry objects are implemented as:</p>
<ul>
<li>numeric vector for <code>POINT</code>,</li>
<li>numeric matrix for <code>MULTIPOINT</code> and <code>LINESTRING</code></li>
<li>list of numeric matrices for <code>MULTILINESTRING</code> and <code>POLYGON</code></li>
<li>list of lists of numeric matrices for <code>MULTIPOLYGON</code></li>
<li>list of (typed) geometries for <code>GEOMETRYCOLLECTION</code></li>
</ul>
<p>All other geometry types follow this, using the simplest possible option. Note that matrices can have zero points, and lists can have zero elements, in which case we have <em>empty</em> geometries; more about this in section <a href="geometries.html#empty">3.2.1.2</a>.</p>
<p>Objects have a class indicating their dimension, type, and a superclass (<code>sfg</code>: simple feature geometry), and have no other attributes than their S3 class:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">pt =</span> <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)))
<span class="co">#&gt; POINT (0 1)</span>
<span class="kw">attributes</span>(pt)
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;XY&quot;    &quot;POINT&quot; &quot;sfg&quot;</span></code></pre></div>
<p>We see that in addition to <code>sfg</code> the <code>class</code> attribute has two values:</p>
<ul>
<li><code>XY</code> telling the dimension of the point(s), can also be <code>XYZ</code>, <code>XYM</code> or <code>XYZM</code></li>
<li><code>POINT</code> revealing the geometry type.</li>
</ul>
<p>Examples of <code>XYZ</code> and <code>XYM</code> and <code>XYZM</code> geometries are found here:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.file</span>(<span class="st">&quot;shape/storms_xyz_feature.shp&quot;</span>, <span class="dt">package=</span><span class="st">&quot;sf&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">st_read</span>()
<span class="co">#&gt; Reading layer `storms_xyz_feature&#39; from data source `/home/edzer/R/x86_64-pc-linux-gnu-library/3.5/sf/shape/storms_xyz_feature.shp&#39; using driver `ESRI Shapefile&#39;</span>
<span class="co">#&gt; Simple feature collection with 71 features and 1 field</span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XYZ</span>
<span class="co">#&gt; bbox:           xmin: -102 ymin: 8.3 xmax: 0 ymax: 59.5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="kw">system.file</span>(<span class="st">&quot;shape/storms_xyzm_feature.shp&quot;</span>, <span class="dt">package=</span><span class="st">&quot;sf&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># badly named!</span>
<span class="st">    </span><span class="kw">st_read</span>()
<span class="co">#&gt; Reading layer `storms_xyzm_feature&#39; from data source `/home/edzer/R/x86_64-pc-linux-gnu-library/3.5/sf/shape/storms_xyzm_feature.shp&#39; using driver `ESRI Shapefile&#39;</span>
<span class="co">#&gt; Simple feature collection with 71 features and 1 field</span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XYM</span>
<span class="co">#&gt; bbox:           xmin: -102 ymin: 8.3 xmax: 0 ymax: 59.5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
(<span class="dt">pzm =</span> <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)))
<span class="co">#&gt; POINT ZM (1 2 3 4)</span></code></pre></div>
<p>A <code>MULTIPOINT</code> or a <code>LINESTRING</code> can be created by a matrix</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">m1 =</span> <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">8</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)))
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    8    1</span>
<span class="co">#&gt; [2,]    2    5</span>
<span class="co">#&gt; [3,]    3    2</span>
(<span class="dt">mp =</span> <span class="kw">st_multipoint</span>(m1))
<span class="co">#&gt; MULTIPOINT (8 1, 2 5, 3 2)</span>
(<span class="dt">ls =</span> <span class="kw">st_linestring</span>(m1))
<span class="co">#&gt; LINESTRING (8 1, 2 5, 3 2)</span></code></pre></div>
<p>Although these geometries contain the same points, they have entirely different meaning: the point set is a zero-dimensional, the line a one-dimensional geometry:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_dimension</span>(mp)
<span class="co">#&gt; [1] 0</span>
<span class="kw">st_dimension</span>(ls)
<span class="co">#&gt; [1] 1</span></code></pre></div>
<p>A <code>MULTILINESTRING</code> can be constructed from a list of matrices, representing vertices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m2 =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">22</span>,<span class="dv">20</span>), <span class="kw">c</span>(<span class="dv">18</span>, <span class="dv">15</span>))
(<span class="dt">mls =</span> <span class="kw">st_multilinestring</span>(<span class="kw">list</span>(m1, m2)))
<span class="co">#&gt; MULTILINESTRING ((8 1, 2 5, 3 2), (22 20, 18 15))</span></code></pre></div>
<p>A <code>POLYGON</code> consists of an outer ring, followed by zero or more inner rings that denote holes in the outer ring:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">ring1 =</span> <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>)))
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    0    0</span>
<span class="co">#&gt; [2,]    4    0</span>
<span class="co">#&gt; [3,]    4    4</span>
<span class="co">#&gt; [4,]    0    4</span>
<span class="co">#&gt; [5,]    0    0</span>
(<span class="dt">p1 =</span> <span class="kw">st_polygon</span>(<span class="kw">list</span>(ring1)))
<span class="co">#&gt; POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))</span>
(<span class="dt">ring2 =</span> ring1 <span class="op">+</span><span class="st"> </span><span class="dv">5</span>)
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    5    5</span>
<span class="co">#&gt; [2,]    9    5</span>
<span class="co">#&gt; [3,]    9    9</span>
<span class="co">#&gt; [4,]    5    9</span>
<span class="co">#&gt; [5,]    5    5</span>
(<span class="dt">ring3 =</span> (ring1[<span class="dv">5</span><span class="op">:</span><span class="dv">1</span>,] <span class="op">/</span><span class="st"> </span><span class="dv">4</span>) <span class="op">+</span><span class="st"> </span><span class="dv">6</span>)
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    6    6</span>
<span class="co">#&gt; [2,]    6    7</span>
<span class="co">#&gt; [3,]    7    7</span>
<span class="co">#&gt; [4,]    7    6</span>
<span class="co">#&gt; [5,]    6    6</span>
(<span class="dt">p2 =</span> <span class="kw">st_polygon</span>(<span class="kw">list</span>(ring2, ring3)))
<span class="co">#&gt; POLYGON ((5 5, 9 5, 9 9, 5 9, 5 5), (6 6, 6 7, 7 7, 7 6, 6 6))</span></code></pre></div>
<p>A <code>MULTIPOLYGON</code> can be constructed as a list of lists of matrices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">mpol =</span> <span class="kw">st_multipolygon</span>(<span class="kw">list</span>(<span class="kw">list</span>(ring1), <span class="kw">list</span>(ring2, ring3))))
<span class="co">#&gt; MULTIPOLYGON (((0 0, 4 0, 4 4, 0 4, 0 0)), ((5 5, 9 5, 9 9, 5 9, 5 5), (6 6, 6 7, 7 7, 7 6, 6 6)))</span></code></pre></div>
<p>And finally, a <code>GEOMETRYCOLLECTION</code> can be constructed from a list of typed geometries:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_geometrycollection</span>(<span class="kw">list</span>(pt, mp, ls, mpol))
<span class="co">#&gt; GEOMETRYCOLLECTION (POINT (0 1), MULTIPOINT (8 1, 2 5, 3 2), LINESTRING (8 1, 2 5, 3 2), MULTIPOLYGON (((0 0, 4 0, 4 4, 0 4, 0 0)), ((5 5, 9 5, 9 9, 5 9, 5 5), (6 6, 6 7, 7 7, 7 6, 6 6))))</span></code></pre></div>
<div id="wkt-wkb-encodings" class="section level4">
<h4><span class="header-section-number">3.2.1.1</span> WKT, WKB encodings</h4>
<p>By default, package <code>sf</code> prints the same number of digits as R, but this can be manipulated:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>))
<span class="co">#&gt; POINT (0.333 0.667)</span>
<span class="kw">print</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>)), <span class="dt">digits =</span> <span class="dv">16</span>)
<span class="co">#&gt; POINT (0.3333333333333333 0.6666666666666666)</span>
<span class="kw">print</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>)), <span class="dt">digits =</span> <span class="dv">3</span>)
<span class="co">#&gt; POINT (0.333 0.667)</span></code></pre></div>
<p>An encoding that is more useful for machine-to-machine communication is <em>well-known binary</em>. An example of a round-trip R <span class="math inline">\(\rightarrow\)</span> binary <span class="math inline">\(\rightarrow\)</span> R is</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">wkb =</span> <span class="kw">st_as_binary</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>))))
<span class="co">#&gt;  [1] 01 01 00 00 00 55 55 55 55 55 55 d5 3f 55 55 55 55 55 55 e5 3f</span>
<span class="kw">st_as_sfc</span>(wkb)[[<span class="dv">1</span>]]
<span class="co">#&gt; POINT (0.333 0.667)</span></code></pre></div>
<p>Object <code>r</code> is a raw vector, which is little useful in R. Binary conversion is used to communicate geometries to external libraries (GDAL, GEOS, liblwgeom) and and spatial databases because it is fast and lossless. Whenever there is a choice, binary encoding should be prefered over text encoding.</p>
</div>
<div id="empty" class="section level4">
<h4><span class="header-section-number">3.2.1.2</span> simple, valid, empty</h4>
<p>Methods <code>st_is_simple</code> and <code>st_is_valid</code> help detect non-simple and non-valid geometries:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_is_simple</span>(<span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)))) <span class="co"># self-intersects</span>
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">st_is_valid</span>(<span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))))) <span class="co"># repeats</span>
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
<p>A very important concept in the feature geometry framework is that of the empty geometry. We can think of an empty geometry as similar to the <code>NA</code> value in R vectors: it is a placeholder, but a usable value is not available. Empty geometries arise naturally when we do geometrical operations (chapter <a href="geommanip.html#geommanip">5</a>), for instance when we want to know where two disjoint geometries coincide:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">e =</span> <span class="kw">st_intersection</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>)), <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))))
<span class="co">#&gt; GEOMETRYCOLLECTION EMPTY</span></code></pre></div>
<p>It is not entirely clear what the benefit is of having <em>typed</em> empty geometries, but according to the simple feature standard they are. They are detected by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_is_empty</span>(e)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
</div>
<div id="conversion-between-geometry-types" class="section level4">
<h4><span class="header-section-number">3.2.1.3</span> Conversion between geometry types</h4>
<p>Up to the extent that a conversion is feasible, we can convert simple feature geometries using the <code>st_cast</code> generic:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">methods</span>(st_cast)
<span class="co">#&gt;  [1] st_cast.CIRCULARSTRING*     st_cast.COMPOUNDCURVE*     </span>
<span class="co">#&gt;  [3] st_cast.CURVE*              st_cast.GEOMETRYCOLLECTION*</span>
<span class="co">#&gt;  [5] st_cast.LINESTRING*         st_cast.MULTILINESTRING*   </span>
<span class="co">#&gt;  [7] st_cast.MULTIPOINT*         st_cast.MULTIPOLYGON*      </span>
<span class="co">#&gt;  [9] st_cast.MULTISURFACE*       st_cast.POINT*             </span>
<span class="co">#&gt; [11] st_cast.POLYGON*            st_cast.sf*                </span>
<span class="co">#&gt; [13] st_cast.sfc*                st_cast.sfc_CIRCULARSTRING*</span>
<span class="co">#&gt; see &#39;?methods&#39; for accessing help and source code</span></code></pre></div>
<p>Conversion is required e.g. to be able to plot curved geometries. <code>CURVE</code>, <code>COMPOUNDCURVE</code> and <code>CIRCULARSTRING</code> have <code>st_cast</code> methods to cast them to <code>LINESTRING</code>; <code>MULTISURFACE</code> has an <code>st_cast</code> method to <code>MULTIPOLYGON</code>. An example, needed for plotting, is</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(ls &lt;-<span class="st"> </span><span class="kw">st_as_sfc</span>(<span class="st">&quot;CIRCULARSTRING(0 0,1 0,1 1)&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_cast</span>(<span class="st">&quot;LINESTRING&quot;</span>))
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: -0.207 xmax: 1.21 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; LINESTRING (0 0, 0.0361 -0.0337, 0.0745 -0.0647...</span>
<span class="kw">plot</span>(ls, <span class="dt">axes =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="sdsr_files/figure-html/unnamed-chunk-53-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>It is convenient in other cases to analyse the point pattern from a set of vertices in a linestring. However,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_linestring</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_cast</span>(<span class="st">&quot;POINT&quot;</span>)
<span class="co">#&gt; Warning in st_cast.LINESTRING(., &quot;POINT&quot;): point from first coordinate only</span>
<span class="co">#&gt; POINT (0 0)</span></code></pre></div>
<p>does not what we expect, because it will convert a single geometry into a new single geometry. We can convert to a <code>MULTIPOINT</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_linestring</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_cast</span>(<span class="st">&quot;POINT&quot;</span>)
<span class="co">#&gt; Warning in st_cast.LINESTRING(., &quot;POINT&quot;): point from first coordinate only</span>
<span class="co">#&gt; POINT (0 0)</span></code></pre></div>
<p>but if we want to have a set of points, we need to work with sets (section @(sfc)) first, because we want a set with another cardinality:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(p &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_linestring</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_sfc</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_cast</span>(<span class="st">&quot;POINT&quot;</span>))
<span class="co">#&gt; Geometry set for 4 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 1 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT (0 0)</span>
<span class="co">#&gt; POINT (1 1)</span>
<span class="co">#&gt; POINT (1 0)</span>
<span class="co">#&gt; POINT (0 1)</span></code></pre></div>
</div>
<div id="geometrycollection-handling" class="section level4">
<h4><span class="header-section-number">3.2.1.4</span> <code>GEOMETRYCOLLECTION</code> handling</h4>
<p>Single features can have a geometry that consists of several subgeometries of different type, held in a <code>GEOMETRYCOLLECTION</code>. This may sound like looking for trouble, but these arise rather naturally when looking for intersections. For instance, the intersection of two <code>LINESTRING</code> geometries may be the combination of a <code>LINESTRING</code> and a <code>POINT</code>. Putting this intersection into a single feature geometry needs a <code>GEOMETRYCOLLECTION</code>.</p>
<p>In case we end up with <code>GEOMETRYCOLLECTION</code> objects, the next question is often what to do with them. One thing we can do is extract elements from them:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pt &lt;-<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>))
ls &lt;-<span class="st"> </span><span class="kw">st_linestring</span>(<span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">2</span>))
poly1 &lt;-<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">matrix</span>(<span class="kw">c</span>(<span class="fl">5.5</span>, <span class="dv">7</span>, <span class="dv">7</span>, <span class="dv">6</span>, <span class="fl">5.5</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">-0.5</span>, <span class="fl">-0.5</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)))
poly2 &lt;-<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">matrix</span>(<span class="kw">c</span>(<span class="fl">6.6</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">7</span>, <span class="fl">6.6</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="fl">1.5</span>, <span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)))
multipoly &lt;-<span class="st"> </span><span class="kw">st_multipolygon</span>(<span class="kw">list</span>(poly1, poly2))

j &lt;-<span class="st"> </span><span class="kw">st_geometrycollection</span>(<span class="kw">list</span>(pt, ls, poly1, poly2, multipoly))

<span class="kw">st_collection_extract</span>(j, <span class="st">&quot;POLYGON&quot;</span>)
<span class="co">#&gt; Geometry set for 3 features </span>
<span class="co">#&gt; geometry type:  MULTIPOLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 5.5 ymin: -0.5 xmax: 8 ymax: 1.5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; MULTIPOLYGON (((5.5 0, 7 0, 7 -0.5, 6 -0.5, 5.5...</span>
<span class="co">#&gt; MULTIPOLYGON (((6.6 1, 8 1, 8 1.5, 7 1.5, 6.6 1)))</span>
<span class="co">#&gt; MULTIPOLYGON (((5.5 0, 7 0, 7 -0.5, 6 -0.5, 5.5...</span>
<span class="kw">st_collection_extract</span>(j, <span class="st">&quot;POINT&quot;</span>)
<span class="co">#&gt; POINT (1 0)</span>
<span class="kw">st_collection_extract</span>(j, <span class="st">&quot;LINESTRING&quot;</span>)
<span class="co">#&gt; LINESTRING (4 0, 3 0)</span></code></pre></div>
<p>which sometimes results in a geometry set, sometimes in single geometries.</p>
</div>
</div>
<div id="sfc" class="section level3">
<h3><span class="header-section-number">3.2.2</span> <code>sfc</code>: sets of geometries</h3>
<p>Rather than handling geometries individually, we typically handle them as sets. Package <code>sf</code> provides a dedicated class for this, called <code>sfc</code> (for <strong>s</strong>imple <strong>f</strong>eature geometry list <strong>c</strong>olumn). We can create such a list column with constructor function <code>st_sfc</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">sfc =</span> <span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)), <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">3</span>,<span class="dv">2</span>)), <span class="dt">crs =</span> <span class="dv">4326</span>))
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -3 ymin: 1 xmax: 0 ymax: 2</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt; POINT (0 1)</span>
<span class="co">#&gt; POINT (-3 2)</span></code></pre></div>
<p>The default report from the <code>print</code> method for <code>sfc</code> gives</p>
<ul>
<li>the number of features geometries</li>
<li>the feature geometry type (here: <code>POINT</code>)</li>
<li>the feature geometry dimension (here: <code>XY</code>)</li>
<li>the bounding box for the set</li>
<li>the coordinate reference system for the set (<code>epsg</code> and <code>proj4string</code>: see chapter <a href="rs.html#crs">7.3</a>)</li>
<li>the first few geometries, as (abbreviated) WKT</li>
</ul>
<p>The class of the geometry list-column,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(sfc)
<span class="co">#&gt; [1] &quot;sfc_POINT&quot; &quot;sfc&quot;</span></code></pre></div>
<p>is again a combination of a specific class, and a superclass. In addition to a <code>class</code>, the object has further attributes</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attributes</span>(sfc) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">names</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">setdiff</span>(<span class="st">&quot;class&quot;</span>)
<span class="co">#&gt; [1] &quot;precision&quot; &quot;bbox&quot;      &quot;crs&quot;       &quot;n_empty&quot;</span></code></pre></div>
<p>which are used to record <em>for the hole set</em>:</p>
<ul>
<li>a precision value (section <a href="geommanip.html#precision">5.4</a>)</li>
<li>the bounding box enclosing all geometries (for x and y)</li>
<li>a coordinate reference system (section <a href="rs.html#crs">7.3</a>)</li>
<li>the number of empty geometries contained in the set</li>
</ul>
<p>This means that all these properties are defined for the set, and not for geometries individually.</p>
<p>As we’ve seen above, sets of geometries arise when we tear apart compound geometries, as in</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(p &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_linestring</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_sfc</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_cast</span>(<span class="st">&quot;POINT&quot;</span>))
<span class="co">#&gt; Geometry set for 4 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 1 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT (0 0)</span>
<span class="co">#&gt; POINT (1 1)</span>
<span class="co">#&gt; POINT (1 0)</span>
<span class="co">#&gt; POINT (0 1)</span></code></pre></div>
<p>Here, <code>st_sfc</code> creates a set of one <code>LINESTRING</code>, and the resulting set has size 4:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(p)
<span class="co">#&gt; [1] 4</span></code></pre></div>
<p>Going the other way around, we need <code>st_combine</code> to combine geometries into one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p <span class="op">%&gt;%</span><span class="st"> </span>st_combine
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  MULTIPOINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 1 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; MULTIPOINT (0 0, 1 1, 1 0, 0 1)</span>
p <span class="op">%&gt;%</span><span class="st"> </span>st_combine <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_cast</span>(<span class="st">&quot;LINESTRING&quot;</span>)
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 1 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; LINESTRING (0 0, 1 1, 1 0, 0 1)</span></code></pre></div>
<p>More general, in practice we will almost always work with sets of geometries, because in spatial data we typically associate an observation with a feature, which has a geometry, and we work with sets of observations.</p>
<p><code>sfc</code> objects are lists with each entry being an <code>sfg</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p[[<span class="dv">2</span>]]
<span class="co">#&gt; POINT (1 1)</span></code></pre></div>
<p>and we will use these lists as <em>list columns</em> in <code>data.frame</code> or <code>tibble</code> objects to represent simple features with geometries in a list column. These objects are of class <code>sf</code> (section @ref{sf}).</p>
<div id="feature-sets-with-mixed-geometries" class="section level4">
<h4><span class="header-section-number">3.2.2.1</span> Feature sets with mixed geometries</h4>
<p>Sets of simple features also consist of features with heterogeneous geometries. In this case, the geometry type of the set is <code>GEOMETRY</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">g =</span> <span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>)), <span class="kw">st_linestring</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>)))))
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  GEOMETRY</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 1 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT (0 0)</span>
<span class="co">#&gt; LINESTRING (0 0, 1 1)</span></code></pre></div>
<p>These can be filtered by using <code>st_is</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_is</span>(<span class="st">&quot;LINESTRING&quot;</span>)
<span class="co">#&gt; [1] FALSE  TRUE</span></code></pre></div>
<p>or, when working with <code>sf</code> objects,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_sf</span>(g) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="kw">st_is</span>(., <span class="st">&quot;LINESTRING&quot;</span>))
<span class="co">#&gt; Simple feature collection with 1 feature and 0 fields</span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 0 xmax: 1 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt;                       g</span>
<span class="co">#&gt; 1 LINESTRING (0 0, 1 1)</span></code></pre></div>
</div>
</div>
<div id="sf" class="section level3">
<h3><span class="header-section-number">3.2.3</span> <code>sf</code>: geometries with attributes</h3>
<p><code>sf</code> objects are <code>tibbles</code> or <code>data.frame</code>s with feature geometry in a list column, and an <code>sf</code> class added:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sf =<span class="st"> </span><span class="kw">st_sf</span>(sfc)
<span class="kw">class</span>(sf)
<span class="co">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></code></pre></div>
<p>Although there is nothing against simply using data.frames or tibbles with <code>sfc</code> list columns, a number of methods have been written for <code>sf</code> objects that make life even more convenient, including plot methods to create maps.</p>
<p>In addition to the usual <code>data.frame</code> attributes, <code>sf</code> objects have two more attributes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sf <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">attributes</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">names</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">c</span>(<span class="st">&quot;row.names&quot;</span>, <span class="st">&quot;class&quot;</span>, <span class="st">&quot;names&quot;</span>))
<span class="co">#&gt; [1] &quot;sf_column&quot; &quot;agr&quot;</span></code></pre></div>
<p>They are:</p>
<ul>
<li><code>sf_column</code>: a length one character vector with the name of the (active) geometry list-column. Note that <code>sf</code> objects may contain multiple geometry list-columns, but the one named here is used for all operations, as the ``active’’ geometry.</li>
<li><code>agr</code>: <strong>a</strong>ttribute-<strong>g</strong>eometry <strong>r</strong>elationships; this encodes for each of the attributes how it relates to the geometry (in case of a non-point geometry): is it constant throughout the geometry like a soil type, is it an aggregate over the geometry like a population count, or does it identify the geometry like a state name? This is explained in more depth in section <a href="featureattributes.html#agr">6.1</a>.</li>
</ul>
</div>
</div>
<div id="geomraster" class="section level2">
<h2><span class="header-section-number">3.3</span> Tesselations: coverages, rasters</h2>
<p>A common case in spatial data analysis is that an area is split (tesselated) in a number of non-overlapping regions. Although this can be modelled by a sequence of simple feature geometries (polygons), it is hard to guarantee for a set of simple feature polygons that they overlap nowhere, or that there are no gaps between them.</p>
<p>More fundamental ways of storing such polygons use a <em>topological</em> model, examples of this are found in geographic information systems like GRASS GIS or ArcGIS. Topological models store every boundary between polygons only once, and register which polygon is on either side of a boundary.</p>
<p>A simpler approach, associated with the term <em>raster data</em>, is to tesselate each spatial dimension <span class="math inline">\(d\)</span> into regular cells, formed e.g. by left-closed and right-open intervals <span class="math inline">\(d_i\)</span>: <span class="math display">\[d_i = d_0 + [~ i \cdot \delta, (i+1) \cdot \delta~)\]</span> with <span class="math inline">\(d_0\)</span> an offset, <span class="math inline">\(\delta\)</span> the interval (cell or pixel) size, and where the cell index <span class="math inline">\(i\)</span> is an arbitrary but consecutive set of integers.</p>
<p>In arbitrary polygon tesselations, assigning points to polygons when they fall on a boundary shared by two polygons is ambiguous. Using left-closed “[” and right-open “)” intervals in regular tesselations removes this ambiguity.</p>
<p>Tesselating the time dimension in this way is very common, and reflects the implicit assumption underlying time series packages such as <code>xts</code> in R. Different models can be combined: one could use simple feature polygons to tesselate space, and combine this with a regular tesselation of time in order to cover a space-time <em>vector datacube</em>. Raster data and data cubes are discussed in chapter <a href="raster.html#raster">4</a>.</p>
</div>
<div id="networks" class="section level2">
<h2><span class="header-section-number">3.4</span> Networks</h2>
<p>Spatial networks are typically composed of linear (<code>LINESTRING</code>) elements, but possess further topological properties describing the network coherence:</p>
<ul>
<li>start and endpoints of a linestring may be connected to other linestring start or end points, forming a set of nodes and edges</li>
<li>edges may be directed, and allow for connections (flow, transport) in only one way.</li>
</ul>
<p>Several R packages (<code>osmar</code>, <code>stplanr</code>) have (limited) functionality available for constructing network objects, and working with them, e.g. computing shortest or fastest routes through a network.</p>
</div>
<div id="geometries-on-the-sphere" class="section level2">
<h2><span class="header-section-number">3.5</span> Geometries on the sphere</h2>
<p>Geometries on the sphere are geometries made from geodetic coordinates. The easiest of these concern small regions near the equator not covering the date line, because in that case we can ignore all problems and still do a good job. Reality is nastier.</p>
<p>The concept of a bounding box, defined from the coordinate ranges breaks easily down, e.g. when crossing the date line:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pts =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">179</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">179</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">179</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="op">-</span><span class="dv">179</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="op">-</span><span class="dv">179</span>,<span class="dv">0</span>))
date_line =<span class="st"> </span><span class="kw">st_sfc</span>(<span class="kw">st_polygon</span>(<span class="kw">list</span>(pts)), <span class="dt">crs =</span> <span class="dv">4326</span>)
<span class="kw">st_bbox</span>(date_line) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_sfc</span>()
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  POLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -179 ymin: 0 xmax: 179 ymax: 1</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt; POLYGON ((-179 0, 179 0, 179 1, -179 1, -179 0))</span></code></pre></div>
<p>or when a polygon contains one of the poles:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pts =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">89</span>), <span class="kw">c</span>(<span class="dv">120</span>,<span class="dv">89</span>), <span class="kw">c</span>(<span class="dv">240</span>,<span class="dv">89</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">89</span>))
pole =<span class="st"> </span><span class="kw">st_sfc</span>(<span class="kw">st_polygon</span>(<span class="kw">list</span>(pts)), <span class="dt">crs =</span> <span class="dv">4326</span>)
<span class="kw">st_bbox</span>(pole) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">st_as_sfc</span>()
<span class="co">#&gt; Geometry set for 1 feature </span>
<span class="co">#&gt; geometry type:  POLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 89 xmax: 240 ymax: 89</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt; POLYGON ((0 89, 240 89, 240 89, 0 89, 0 89))</span></code></pre></div>
<p>where we see that in both cases the <code>st_bbox</code> implied polygon does not cover the area intended.</p>
<div id="straight-lines" class="section level3">
<h3><span class="header-section-number">3.5.1</span> Straight lines?</h3>
<p>The simple feature model assumes that linestrings and polygons are formed of points connected by straight lines. When however representing the Earth surface, what does a straight line mean? The simple feature standard does not help much, here: it assumes Carthesian space. Technically speaking, a straight line between two points on a sphere exists, but it crosses the sphere, which is not very practical in most cases. The most common case is to use <em>great circle</em> segments to connect points: the shortest path that follows the surface of the sphere or ellipsoid. This means that (with longitude latitude coordinates) the line between <code>POINT(0 50)</code> and <code>POINT(10 50)</code> does not cross <code>POINT(5 50)</code>. It also means that the line between points on opposite sides of the sphere is ambiguous. Also, the direction of a great circle segment, when defined as the angle it has with meridians, is not constant.</p>
</div>
<div id="ring-direction-for-polygons" class="section level3">
<h3><span class="header-section-number">3.5.2</span> Ring direction for polygons</h3>
<p>The simple feature standard is not conclusive about the direction of points in a ring. It points out that exterior rings should be counter clockwise, when seen from above, and interior rings (holes) clockwise, but for instance <code>st_is_valid</code> does not invalidate clockwise exterior rings:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_is_valid</span>(<span class="kw">st_polygon</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>)))))
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>This may have several reasons: a lot of data may come with wrong ring directions, and the distinction between exterior and interior rings is already unambiguous by their order: the first is exterior, anything following is interior.</p>
<p>On the sphere, any polygon divides the sphere surface in two finite areas, meaning there is no longer an unambiguous “inside” vs. “outside”: does the polygon with longitude latitude coordinates <code>POLYGON((0 0, 120 0, 240 0, 0 0))</code> denote the northern or the southern hemisphere? One can still go two directions here:</p>
<ul>
<li>assume that in practice polygons never divide the Earth in two equal halves, and take the smaller area as the “inside”</li>
<li>decide strongly about ring direction, e.g. counter-clockwise (following the ring, standing on the Earth, the left-side of the ring denotes the polygon interior)</li>
</ul>
<p>Package <code>sf</code> comes with a large amount of functions that work both for projected (Cartesian) data as for data defined in spherical coordinates. Whenever it makes assumptions of Cartesian coordinates for spherical coordinates it emits a warning. This is discussed further in section <a href="geommanip.html#longlat">5.5</a>.</p>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-sfa">
<p>Herring, John R. 2011. “OpenGIS Implementation Standard for Geographic Information-Simple Feature Access-Part 1: Common Architecture.” <em>Open Geospatial Consortium Inc</em>, 111. <a href="http://portal.opengeospatial.org/files/?artifact_id=25355" class="uri">http://portal.opengeospatial.org/files/?artifact_id=25355</a>.</p>
</div>
<div id="ref-sfa2">
<p>Herring, John R. 2010. “OpenGIS Implementation Standard for Geographic Information-Simple Feature Access-Part 2: SQL Option.” <em>Open Geospatial Consortium Inc</em>. <a href="http://portal.opengeospatial.org/files/?artifact_id=25354" class="uri">http://portal.opengeospatial.org/files/?artifact_id=25354</a>.</p>
</div>
<div id="ref-iso">
<p>ISO. 2004. <em>Geographic Information – Simple Feature Access – Part 1: Common Architecture</em>. <a href=" https://www.iso.org/standard/40114.html ">https://www.iso.org/standard/40114.html</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="cs.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="raster.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/edzer/sdsr/edit/master/03-Geometries.Rmd",
"text": "Edit"
},
"download": ["sdsr.pdf", "sdsr.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
